// Generated by CoffeeScript 1.9.3
(function() {
  var Buffer, Callback, Channel, Generator, Multicast, Process, Selector, alias, chan, final, fn, go, i, len, mult, name, offer, poll, proc, receive, ref, ref1, select, send, sleep, timeout,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Process = require('./process');

  Channel = require('./channel');

  Buffer = require('./buffer');

  Selector = require('./selector');

  Callback = require('./callback');

  ref = require('./helpers'), alias = ref.alias, Generator = ref.Generator;

  proc = function(generator, args) {
    return Process.spawn.apply(Process, arguments);
  };

  proc.async = (function() {
    var Async, async;
    Async = (function(superClass) {
      extend(Async, superClass);

      function Async(generator1, args1, callback1) {
        this.generator = generator1;
        this.args = args1;
        this.callback = callback1;
        Async.__super__.constructor.apply(this, arguments);
      }

      Async.prototype.next = function(input) {
        var error, output;
        switch (++this._step) {
          case 1:
            return this["yield"](receive(proc(this.generator, this.args)));
          case 2:
            try {
              output = this.callback(null, input);
            } catch (_error) {
              error = _error;
              this.callback(error);
            }
            return this["return"](output);
        }
      };

      return Async;

    })(Generator);
    return async = function(generator) {
      return function(_) {
        var g;
        g = function() {
          var args, callback, i;
          args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
          return new Async(generator, args, callback);
        };
        proc(g, arguments);
      };
    };
  })();

  (function() {
    var f, i, len, name, ref1;
    f = function(name) {
      return function() {
        var ref1;
        return (ref1 = Process.current())[name].apply(ref1, arguments);
      };
    };
    ref1 = "enqueue dequeue isClosed isDone canProcessReceive canProcessSend".split(/\s+/);
    for (i = 0, len = ref1.length; i < len; i++) {
      name = ref1[i];
      proc[name] = f(name);
    }
  })();

  proc.list = Process.list;

  proc.tree = Process.tree;

  go = function() {
    var p;
    p = Process.spawn.apply(Process, arguments);
    return p.out();
  };

  chan = function(buffer, transducer) {
    var ch;
    return ch = new Channel(buffer, transducer);
  };

  ref1 = ['fixed', 'sliding', 'dropping'];
  for (i = 0, len = ref1.length; i < len; i++) {
    name = ref1[i];
    fn = Buffer[name];
    chan[name] = (function(fn) {
      return function() {
        var rest, size;
        size = arguments[0], rest = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return chan.apply(null, [fn(size)].concat(slice.call(rest)));
      };
    })(fn);
  }

  chan.single = function(transducer) {
    var callback, ch;
    ch = chan(null, transducer);
    receive.async(ch, callback = function(value) {
      if (ch.buffer != null) {
        ch.buffer.close();
        ch.buffer = null;
      }
      ch.flags |= 8;
      return ch.close(value);
    });
    return ch;
  };

  final = function() {
    return Process.current().isFinal;
  };

  receive = function() {
    switch (arguments.length) {
      case 0:
        return receive.$0.apply(receive, arguments);
      case 1:
        return receive.$1.apply(receive, arguments);
      default:
        throw new Error("Arity");
    }
  };

  receive.$0 = function() {
    var p;
    p = Process.current();
    return p._in().dequeue(p);
  };

  receive.$1 = function(channel) {
    return channel.dequeue(Process.current());
  };

  receive.async = function(channel, fn) {
    var callback, done, immediate, result;
    callback = Callback.alloc(fn);
    done = channel.isDone();
    immediate = channel.canProcessReceive();
    result = channel.dequeue(callback);
    if (done || immediate) {
      callback.proceed(result, done);
    }
  };

  send = function() {
    switch (arguments.length) {
      case 1:
        return send.$1.apply(send, arguments);
      case 2:
        return send.$2.apply(send, arguments);
      default:
        throw new Error("Arity");
    }
  };

  send.$1 = function(value) {
    var p;
    p = Process.current();
    return p._out().enqueue(p, value);
  };

  send.$2 = function(channel, value) {
    return channel.enqueue(Process.current(), value);
  };

  send.async = function(channel, value, fn) {
    var callback, closed, immediate, result;
    callback = Callback.alloc(fn);
    closed = channel.isClosed();
    immediate = channel.canProcessSend();
    result = channel.enqueue(callback, value);
    if (closed || immediate) {
      callback.proceed(result, closed);
    }
    return !closed;
  };

  select = Selector.select;

  poll = function() {
    var channel;
    switch (arguments.length) {
      case 0:
        channel = Process.current()._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessReceive()) {
      return receive.async(channel);
    }
  };

  offer = function() {
    var channel, value;
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = Process.current()._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessSend()) {
      return send.async(channel, value);
    } else {
      return false;
    }
  };

  timeout = function() {
    var args, ch, fn, ms;
    ms = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    ch = chan();
    if (typeof ms === 'function') {
      fn = arguments[0], ms = arguments[1];
    }
    setTimeout(((function(_this) {
      return function() {
        return ch.close(fn != null ? fn.apply(_this, args) : void 0);
      };
    })(this)), ms);
    return ch.out();
  };

  sleep = function() {
    return receive(timeout.apply(null, arguments));
  };

  mult = function(channel) {
    return new Multicast(channel);
  };

  alias({
    single: 'promise'
  }, chan);

  alias({
    receive: 'get take',
    send: 'put',
    select: 'alts'
  }, select, module.exports = {
    proc: proc,
    chan: chan,
    go: go,
    final: final,
    receive: receive,
    send: send,
    select: select,
    poll: poll,
    offer: offer,
    timeout: timeout,
    sleep: sleep,
    mult: mult
  });

  Multicast = require('./multicast');

}).call(this);
