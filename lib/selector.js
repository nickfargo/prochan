// Generated by CoffeeScript 1.10.0
(function() {
  var Operation, Process, Selector, isArray,
    slice = [].slice;

  Process = require('./process');

  Operation = require('./operation');

  isArray = require('./helpers').isArray;

  module.exports = Selector = (function() {
    var COMMITTED, DELEGATED, EVALUATED, FINALIZED, IMMEDIATE, INCIPIENT, INITIAL_ITERATOR_RESULT, Receive, Send, destructure, first, last, randomly;

    Receive = Operation.Receive, Send = Operation.Send;

    INCIPIENT = 0x01;

    IMMEDIATE = 0x02;

    EVALUATED = 0x04;

    DELEGATED = 0x08;

    COMMITTED = 0x10;

    FINALIZED = 0x20;

    Selector.prototype[(typeof Symbol !== "undefined" && Symbol !== null ? Symbol.iterator : void 0) || '@@iterator'] = function() {
      return this;
    };

    INITIAL_ITERATOR_RESULT = {
      value: void 0,
      done: false
    };

    function Selector() {
      this.flags = INCIPIENT;
      this.process = Process.current();
      this.candidates = [];
      this.alternative = null;
      this.arbiter = null;
      this.delegate = null;
      this.result = null;
    }

    first = function(a) {
      return a[0];
    };

    last = function(a) {
      return a[a.length - 1];
    };

    randomly = function(a) {
      return a[Math.random() * a.length | 0];
    };

    destructure = function() {
      var args, consequent, lastArg;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      switch (typeof (lastArg = args.pop())) {
        case 'function':
        case 'string':
          consequent = lastArg;
          break;
        default:
          if (lastArg != null) {
            args.push(lastArg);
          }
      }
      return [args, consequent];
    };

    Selector.select = function() {
      var consequent, i, len, op, operations, ref, s;
      ref = destructure.apply(null, arguments), operations = ref[0], consequent = ref[1];
      s = new Selector;
      for (i = 0, len = operations.length; i < len; i++) {
        op = operations[i];
        if (isArray(op)) {
          s.send(op, consequent);
        } else {
          s.receive(op, consequent);
        }
      }
      return s;
    };

    Selector.select.receive = function() {
      var ref;
      return (ref = new Selector).receive.apply(ref, arguments);
    };

    Selector.select.send = function() {
      var ref;
      return (ref = new Selector).send.apply(ref, arguments);
    };

    Selector.select.first = function() {
      return (new Selector).arbitrate(first);
    };

    Selector.select.last = function() {
      return (new Selector).arbitrate(last);
    };

    Selector.prototype.receive = function() {
      var channel, channels, consequent, i, len, noneAreReadyYet, ref, thisOneIsReady;
      if (~this.flags & INCIPIENT) {
        throw new Error("Late");
      }
      ref = destructure.apply(null, arguments), channels = ref[0], consequent = ref[1];
      for (i = 0, len = channels.length; i < len; i++) {
        channel = channels[i];
        if (!(channel != null)) {
          continue;
        }
        noneAreReadyYet = ~this.flags & IMMEDIATE;
        thisOneIsReady = channel.canProcessReceive();
        if (noneAreReadyYet || thisOneIsReady) {
          if (noneAreReadyYet && thisOneIsReady) {
            this.flags |= IMMEDIATE;
            this.clear();
          }
          this.candidates.push(Receive.alloc(this, consequent, channel));
        }
      }
      return this;
    };

    Selector.prototype.send = function() {
      var channel, consequent, i, len, noneAreReadyYet, pairs, ref, ref1, thisOneIsReady, value;
      if (~this.flags & INCIPIENT) {
        throw new Error("Late");
      }
      ref = destructure.apply(null, arguments), pairs = ref[0], consequent = ref[1];
      for (i = 0, len = pairs.length; i < len; i++) {
        ref1 = pairs[i], channel = ref1[0], value = ref1[1];
        if (!(channel != null)) {
          continue;
        }
        noneAreReadyYet = ~this.flags & IMMEDIATE;
        thisOneIsReady = channel.canProcessSend();
        if (noneAreReadyYet || thisOneIsReady) {
          if (noneAreReadyYet && thisOneIsReady) {
            this.flags |= IMMEDIATE;
            this.clear();
          }
          this.candidates.push(Send.alloc(this, consequent, channel, value));
        }
      }
      return this;
    };

    Selector.prototype["else"] = function(alternative) {
      if (~this.flags & INCIPIENT) {
        throw new Error("Early");
      }
      this.flags &= ~INCIPIENT;
      if (this.flags & EVALUATED || (this.alternative != null)) {
        throw new Error("Late");
      }
      this.alternative = alternative;
      return this;
    };

    Selector.prototype.arbitrate = function(arbiter) {
      if (this.flags & EVALUATED || (this.arbiter != null)) {
        throw new Error("Late");
      }
      this.arbiter = arbiter;
      return this;
    };

    Selector.prototype.induce = function(p) {
      if (p !== this.process) {
        throw new Error("Process mismatch");
      }
      if (this.flags & EVALUATED) {
        throw new Error("Late");
      }
      this.evaluate();
      if (this.flags & COMMITTED) {
        return this.process.value = this.result;
      }
    };

    Selector.prototype.next = function(value) {
      var result;
      if (~this.flags & EVALUATED) {
        this.flags |= DELEGATED;
        this.evaluate();
      }
      if (~this.flags & DELEGATED) {
        throw new Error("Expected a delegated generator");
      }
      if (~this.flags & COMMITTED) {
        return INITIAL_ITERATOR_RESULT;
      } else {
        result = this.delegate.next(value);
        if (result.done) {
          this.finalize();
        }
        return result;
      }
    };

    Selector.prototype.evaluate = function() {
      var i, len, op, ref;
      if (this.flags & EVALUATED) {
        throw new Error("Already evaluated");
      }
      this.flags = this.flags & ~INCIPIENT | EVALUATED;
      if (this.flags & IMMEDIATE) {
        op = (this.arbiter || randomly)(this.candidates);
      }
      if (op != null) {
        this.commit(op);
      } else if (this.alternative != null) {
        this.commit(null);
      } else {
        this.process.block(this);
        ref = this.candidates;
        for (i = 0, len = ref.length; i < len; i++) {
          op = ref[i];
          op.detain();
        }
      }
    };

    Selector.prototype.commit = function(operation, value) {
      var channel, consequent;
      if (this.flags & COMMITTED) {
        throw new Error("Already committed");
      }
      this.flags |= COMMITTED;
      if (operation != null) {
        if (operation.selector !== this) {
          throw new Error("Foreign operation");
        }
        if (this.flags & IMMEDIATE) {
          value = operation.execute();
        }
        consequent = operation.consequent, channel = operation.channel;
        if (this.flags & DELEGATED) {
          this.delegate = consequent(value, channel);
        } else {
          this.result = {
            label: consequent,
            value: value,
            channel: channel
          };
        }
      } else {
        if (this.flags & DELEGATED) {
          this.delegate = this.alternative();
        } else {
          this.result = {
            label: this.alternative,
            value: void 0,
            channel: null
          };
        }
      }
      this.clear();
      this.alternative = null;
      this.arbiter = null;
    };

    Selector.prototype.proceedWith = function(operation, value, isFinal) {
      var output;
      if (this.flags & IMMEDIATE) {
        throw new Error("Requires blocking select");
      }
      this.process.register(operation.value, isFinal);
      this.commit(operation, value);
      output = this.flags & DELEGATED ? value : this.result;
      return this.process.proceed(output, isFinal);
    };

    Selector.prototype.clear = function() {
      var op;
      while (op = this.candidates.pop()) {
        op.free();
      }
    };

    Selector.prototype.finalize = function() {
      this.flags |= FINALIZED;
      this.process = null;
      this.delegate = null;
      this.result = null;
    };

    return Selector;

  })();

}).call(this);
