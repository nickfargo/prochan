// Generated by CoffeeScript 1.9.3
(function() {
  var Operation, Process, Selector, isArray,
    slice = [].slice;

  Process = require('./process');

  Operation = require('./operation');

  isArray = require('./helpers').isArray;

  module.exports = Selector = (function() {
    var ACTIVATED, COMMITTED, COMPLETED, IMMEDIATE, INCIPIENT, Receive, Send, delegable, destructure, first, last, randomly;

    Receive = Operation.Receive, Send = Operation.Send;

    INCIPIENT = 0x01;

    ACTIVATED = 0x02;

    COMMITTED = 0x04;

    COMPLETED = 0x08;

    IMMEDIATE = 0x10;

    Selector.prototype[(typeof Symbol !== "undefined" && Symbol !== null ? Symbol.iterator : void 0) || '@@iterator'] = function() {
      return this;
    };

    function Selector() {
      this.flags = INCIPIENT;
      this.process = Process.current();
      this.operations = [];
      this.alternative = null;
      this.arbiter = null;
      this.delegate = null;
      this.value = void 0;
    }

    first = function(a) {
      return a[0];
    };

    last = function(a) {
      return a[a.length - 1];
    };

    randomly = function(a) {
      return a[Math.random() * a.length | 0];
    };

    delegable = function(label) {
      if (typeof label === 'function') {
        return label;
      } else {
        return function(value, channel) {
          return {
            next: function() {
              return {
                value: {
                  label: label,
                  value: value,
                  channel: channel
                },
                done: true
              };
            }
          };
        };
      }
    };

    destructure = function() {
      var args, consequent, i;
      args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), consequent = arguments[i++];
      switch (typeof consequent) {
        case 'function':
          break;
        case 'string':
          consequent = delegable(consequent);
          break;
        default:
          args.push(consequent);
          consequent = delegable();
      }
      return [args, consequent];
    };

    Selector.select = function() {
      var consequent, i, len, op, operations, ref, s;
      ref = destructure.apply(null, arguments), operations = ref[0], consequent = ref[1];
      s = new Selector;
      for (i = 0, len = operations.length; i < len; i++) {
        op = operations[i];
        if (isArray(op)) {
          s.send(op, consequent);
        } else {
          s.receive(op, consequent);
        }
      }
      return s;
    };

    Selector.select.receive = function() {
      var ref;
      return (ref = new Selector).receive.apply(ref, arguments);
    };

    Selector.select.send = function() {
      var ref;
      return (ref = new Selector).send.apply(ref, arguments);
    };

    Selector.select.first = function() {
      return (new Selector).arbitrate(first);
    };

    Selector.select.last = function() {
      return (new Selector).arbitrate(last);
    };

    Selector.prototype.receive = function() {
      var channel, channels, consequent, i, len, ready, ref;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), channels = ref[0], consequent = ref[1];
      for (i = 0, len = channels.length; i < len; i++) {
        channel = channels[i];
        if (!(channel != null)) {
          continue;
        }
        ready = channel.canProcessReceive();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Receive.alloc(this, consequent, channel));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            this.clear();
          }
          this.operations.push(Receive.alloc(this, consequent, channel));
        }
      }
      return this;
    };

    Selector.prototype.send = function() {
      var channel, consequent, i, len, pairs, ready, ref, ref1, value;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), pairs = ref[0], consequent = ref[1];
      for (i = 0, len = pairs.length; i < len; i++) {
        ref1 = pairs[i], channel = ref1[0], value = ref1[1];
        if (!(channel != null)) {
          continue;
        }
        ready = channel.canProcessSend();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Send.alloc(this, consequent, channel, value));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            this.clear();
          }
          this.operations.push(Send.alloc(this, consequent, channel, value));
        }
      }
      return this;
    };

    Selector.prototype["else"] = function(alternative) {
      if (~this.flags & INCIPIENT) {
        throw new Error("Early");
      }
      this.flags &= ~INCIPIENT;
      if (this.flags & ACTIVATED || (this.alternative != null)) {
        throw new Error("Late");
      }
      this.alternative = delegable(alternative);
      return this;
    };

    Selector.prototype.arbitrate = function(arbiter) {
      if (this.flags & ACTIVATED || (this.arbiter != null)) {
        throw new Error("Late");
      }
      this.arbiter = arbiter;
      return this;
    };

    Selector.prototype.next = function(value) {
      var i, len, op, ref;
      if (~this.flags & ACTIVATED) {
        this.flags = this.flags & ~INCIPIENT | ACTIVATED;
        if (this.flags & IMMEDIATE) {
          op = (this.arbiter || randomly)(this.operations);
        }
        if (op != null) {
          if (op.type === 'send') {
            value = !op.channel.isClosed();
          }
          this.commit(op, value);
          return this.iterate(value);
        } else if (this.alternative) {
          this.commit();
          return this.iterate();
        } else {
          this.process.block(this);
          ref = this.operations;
          for (i = 0, len = ref.length; i < len; i++) {
            op = ref[i];
            op.detain();
          }
          return {
            value: void 0,
            done: false
          };
        }
      } else {
        return this.iterate(value);
      }
    };

    Selector.prototype.proceedWith = function(operation, value, isFinal) {
      this.commit(operation, value);
      this.flags |= ACTIVATED;
      this.process.value = this.value;
      return this.process.proceed(value, isFinal);
    };

    Selector.prototype.commit = function(operation, value) {
      if (this.flags & COMMITTED) {
        throw new Error("Already committed");
      }
      this.flags |= COMMITTED;
      if (operation != null) {
        if (operation.selector !== this) {
          throw new Error("Foreign operation");
        }
        this.value = operation.value;
        this.delegate = operation.consequent(value, operation.channel);
      } else {
        this.delegate = this.alternative();
      }
      this.clear();
      this.alternative = null;
      this.arbiter = null;
    };

    Selector.prototype.iterate = function(value) {
      var result;
      result = this.delegate.next(value);
      if (result.done) {
        this.complete();
      }
      return result;
    };

    Selector.prototype.clear = function() {
      var op;
      while (op = this.operations.pop()) {
        op.free();
      }
    };

    Selector.prototype.complete = function() {
      this.flags = COMPLETED;
      this.process = null;
      this.delegate = null;
      return this.value = void 0;
    };

    return Selector;

  })();

}).call(this);
