// Generated by CoffeeScript 1.9.3
(function() {
  var BLOCKED, BLOCK_SIZE, CLOSED, EMPTY, ERROR, FULL, INCIPIENT, PULLED, PUSHED, RUNNING, SCHEDULED, STOPPED, TERMINATED, assert, async, chan, expect, proc, receive, ref, ref1, send;

  ref = require('chai'), assert = ref.assert, expect = ref.expect;

  ref1 = require('prochan'), proc = ref1.proc, chan = ref1.chan, send = ref1.send, receive = ref1.receive;

  async = proc.async;

  CLOSED = 0x10;

  EMPTY = 0x08;

  FULL = 0x04;

  PUSHED = 0x02;

  PULLED = 0x01;

  INCIPIENT = 0x01;

  SCHEDULED = 0x02;

  RUNNING = 0x04;

  BLOCKED = 0x08;

  STOPPED = 0x10;

  TERMINATED = 0x20;

  ERROR = 0x40;

  BLOCK_SIZE = 32;

  describe("Buffer:", function() {
    describe("Zero:", function() {
      return it("behaves like an unbuffered channel", async(function*() {
        var c, p, q;
        c = chan(0);
        q = c.buffer.queue;
        p = proc(function*() {
          var i, j;
          for (i = j = 1; j <= 5; i = ++j) {
            (yield send(c, i));
          }
          return c.close();
        });
        return (yield receive(proc(function*() {
          var ref2, ref3, ref4, ref5, ref6, ref7;
          assert(c.flags === (EMPTY | FULL | PUSHED));
          assert((c.head === (ref2 = c.tail) && ref2 === p));
          assert(q.length === 0);
          assert(q.offset === 0);
          assert((q.head === (ref3 = q.tail) && ref3 === null));
          expect((yield receive(proc(function*() {
            var i, j, results;
            results = [];
            for (i = j = 1; j <= 3; i = ++j) {
              results.push((yield receive(c)));
            }
            return results;
          })))).to.deep.equal([1, 2, 3]);
          assert(c.flags === (EMPTY | FULL | PUSHED));
          assert((c.head === (ref4 = c.tail) && ref4 === p));
          assert(q.length === 0);
          assert(q.offset === 0);
          assert((q.head === (ref5 = q.tail) && ref5 === null));
          expect((yield receive(proc(function*() {
            var results;
            results = [];
            while (!c.isDone()) {
              results.push((yield receive(c)));
            }
            return results;
          })))).to.deep.equal([4, 5]);
          assert(c.flags === (CLOSED | EMPTY | FULL));
          assert((c.head === (ref6 = c.tail) && ref6 === null));
          assert(q.length === 0);
          assert(q.offset === 0);
          return assert((q.head === (ref7 = q.tail) && ref7 === null));
        })));
      }));
    });
    describe("Fixed:", function() {
      return it("blocks senders when full", async(function*() {
        var c, p, q;
        c = chan.fixed(3);
        q = c.buffer.queue;
        p = proc(function*() {
          var i, j;
          for (i = j = 1; j <= 10; i = ++j) {
            (yield send(c, i));
          }
          return c.close();
        });
        return (yield receive(proc(function*() {
          var ref2, ref3, ref4;
          assert(c.flags === (FULL | PUSHED));
          assert((c.head === (ref2 = c.tail) && ref2 === p));
          assert(q.length === 3);
          assert(q.offset === 0);
          expect((yield receive(proc(function*() {
            var i, j, results;
            results = [];
            for (i = j = 1; j <= 5; i = ++j) {
              results.push((yield receive(c)));
            }
            return results;
          })))).to.deep.equal([1, 2, 3, 4, 5]);
          assert(c.flags === (FULL | PUSHED));
          assert((c.head === (ref3 = c.tail) && ref3 === p));
          assert(q.length === 3);
          assert(q.offset === 0);
          expect((yield receive(proc(function*() {
            var results;
            results = [];
            while (!c.isDone()) {
              results.push((yield receive(c)));
            }
            return results;
          })))).to.deep.equal([6, 7, 8, 9, 10]);
          assert(c.flags === (CLOSED | EMPTY));
          assert((c.head === (ref4 = c.tail) && ref4 === null));
          assert(q.length === 0);
          return assert(q.offset === 0);
        })));
      }));
    });
    describe("Dropping:", function() {
      it("can drop", async(function*() {
        var c, q;
        c = chan.dropping(3);
        q = c.buffer.queue;
        (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 5; i = ++j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === 3);
        assert(q.offset === 0);
        expect((yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 3; i = ++j) {
            results.push((yield receive(c)));
          }
          return results;
        })))).to.deep.equal([1, 2, 3]);
        assert(q.length === 0);
        assert(q.offset === 0);
        assert(q.head === q.tail);
        (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 5; i = ++j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === 3);
        return assert(q.offset === 0);
      }));
      return it("can span many queue blocks", async(function*() {
        var c, j, k, n, q, ref2, ref3, results, results1;
        n = 2 * BLOCK_SIZE + 2;
        c = chan.dropping(n);
        q = c.buffer.queue;
        (yield receive(proc(function*() {
          var i, j, ref2, results;
          results = [];
          for (i = j = 1, ref2 = n + 2; 1 <= ref2 ? j <= ref2 : j >= ref2; i = 1 <= ref2 ? ++j : --j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === n);
        assert(q.offset === 0);
        assert(q.head._next._next === q.tail);
        assert(q.head._next === q.tail._prev);
        assert(q.head === q.tail._prev._prev);
        expect((yield receive(proc(function*() {
          var i, k, ref3, results1;
          results1 = [];
          for (i = k = 1, ref3 = n - 4; 1 <= ref3 ? k <= ref3 : k >= ref3; i = 1 <= ref3 ? ++k : --k) {
            results1.push((yield receive(c)));
          }
          return results1;
        })))).to.deep.equal((function() {
          results = [];
          for (var j = 1, ref2 = n - 4; 1 <= ref2 ? j <= ref2 : j >= ref2; 1 <= ref2 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this));
        assert(q.length === 4);
        assert(q.offset === (BLOCK_SIZE - 2));
        assert(q.head._next === q.tail);
        assert(q.head === q.tail._prev);
        expect((yield receive(proc(function*() {
          var i, l, results2;
          results2 = [];
          for (i = l = 1; l <= 4; i = ++l) {
            results2.push((yield receive(c)));
          }
          return results2;
        })))).to.deep.equal((function() {
          results1 = [];
          for (var k = ref3 = n - 3; ref3 <= n ? k <= n : k >= n; ref3 <= n ? k++ : k--){ results1.push(k); }
          return results1;
        }).apply(this));
        assert(q.length === 0);
        assert(q.offset === 0);
        return assert(q.head === q.tail);
      }));
    });
    return describe("Sliding:", function() {
      it("can slide", async(function*() {
        var c, q;
        c = chan.sliding(3);
        q = c.buffer.queue;
        (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 5; i = ++j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === 3);
        assert(q.offset === 2);
        (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 3; i = ++j) {
            results.push((yield receive(c)));
          }
          return results;
        })));
        assert(q.length === 0);
        assert(q.offset === 0);
        assert(q.head === q.tail);
        (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 5; i = ++j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === 3);
        return assert(q.offset === 2);
      }));
      it("can straddle two adjacent queue blocks", async(function*() {
        var c, q;
        c = chan.sliding(4);
        q = c.buffer.queue;
        (yield receive(proc(function*() {
          var i, j, ref2, results;
          results = [];
          for (i = j = 1, ref2 = BLOCK_SIZE + 2; 1 <= ref2 ? j <= ref2 : j >= ref2; i = 1 <= ref2 ? ++j : --j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === 4);
        assert(q.offset === (BLOCK_SIZE - 2));
        assert(q.head._next === q.tail);
        return assert(q.head === q.tail._prev);
      }));
      return it("can span many queue blocks", async(function*() {
        var c, j, k, q, ref2, ref3, ref4, ref5, results, results1;
        c = chan.sliding(BLOCK_SIZE + 4);
        q = c.buffer.queue;
        (yield receive(proc(function*() {
          var i, j, ref2, results;
          results = [];
          for (i = j = 1, ref2 = BLOCK_SIZE * 2 + 2; 1 <= ref2 ? j <= ref2 : j >= ref2; i = 1 <= ref2 ? ++j : --j) {
            results.push((yield send(c, i)));
          }
          return results;
        })));
        assert(q.length === (BLOCK_SIZE + 4));
        assert(q.offset === (BLOCK_SIZE - 2));
        assert(q.head._next._next === q.tail);
        assert(q.head._next === q.tail._prev);
        assert(q.head === q.tail._prev._prev);
        expect((yield receive(proc(function*() {
          var i, k, results1;
          results1 = [];
          for (i = k = 1; k <= 4; i = ++k) {
            results1.push((yield receive(c)));
          }
          return results1;
        })))).to.deep.equal((function() {
          results = [];
          for (var j = ref2 = BLOCK_SIZE - 1, ref3 = BLOCK_SIZE + 2; ref2 <= ref3 ? j <= ref3 : j >= ref3; ref2 <= ref3 ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this));
        assert(q.length === BLOCK_SIZE);
        assert(q.offset === 2);
        assert(q.head._next === q.tail);
        assert(q.head === q.tail._prev);
        c.close();
        expect((yield receive(proc(function*() {
          var results2;
          results2 = [];
          while (!c.isDone()) {
            results2.push((yield receive(c)));
          }
          return results2;
        })))).to.deep.equal((function() {
          results1 = [];
          for (var k = ref4 = BLOCK_SIZE + 3, ref5 = BLOCK_SIZE * 2 + 2; ref4 <= ref5 ? k <= ref5 : k >= ref5; ref4 <= ref5 ? k++ : k--){ results1.push(k); }
          return results1;
        }).apply(this));
        assert(q.length === 0);
        assert(q.offset === 0);
        return assert(q.head === q.tail);
      }));
    });
  });

}).call(this);
