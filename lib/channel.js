// Generated by CoffeeScript 1.9.3
(function() {
  var Buffer, Channel, attenuate;

  attenuate = require('./helpers').attenuate;

  Buffer = require('./buffer');

  module.exports = Channel = (function() {
    var CLOSED, EMPTY, FULL, Inlet, Outlet, PULLED, PUSHED, uid;

    uid = 0;

    CLOSED = 0x10;

    EMPTY = 0x08;

    FULL = 0x04;

    PUSHED = 0x02;

    PULLED = 0x01;

    function Channel(buffer, transducer) {
      var ref;
      this.id = 'ch' + ++uid;
      this.buffer = null;
      if ((buffer != null) || (transducer != null)) {
        switch (typeof buffer) {
          case 'number':
            this.buffer = new Buffer(buffer, transducer);
            break;
          case 'string':
            this.buffer = Buffer[buffer](1, transducer);
            break;
          case 'function':
            transducer = buffer;
            this.buffer = new Buffer(0, transducer);
            break;
          default:
            this.buffer = buffer != null ? buffer : new Buffer(0, transducer);
        }
        this.buffer.channel = this;
      }
      this.flags = ((ref = this.buffer) != null ? ref.size : void 0) > 0 ? EMPTY : EMPTY | FULL;
      this.head = null;
      this.tail = null;
      this.result = void 0;
    }

    Inlet = (function() {
      function Inlet() {}

      Inlet = attenuate('enqueue detain cancel canProcessSend isClosed close');

      Inlet.prototype["in"] = function() {
        return this;
      };

      return Inlet;

    })();

    Outlet = (function() {
      function Outlet() {}

      Outlet = attenuate('dequeue detain cancel canProcessReceive isDone');

      Outlet.prototype.out = function() {
        return this;
      };

      return Outlet;

    })();

    Channel.prototype.stateIsValid = function() {
      return 1 << this.flags & 0x11117351;
    };

    Channel.prototype.canProcessSend = function() {
      return 1 << this.flags & 0x00002301;
    };

    Channel.prototype.canProcessReceive = function() {
      return 1 << this.flags & 0x00114051;
    };

    Channel.prototype.isClosed = function() {
      return 1 << this.flags & 0x11110000;
    };

    Channel.prototype.isDone = function() {
      return 1 << this.flags & 0x11000000;
    };

    Channel.prototype["in"] = function() {
      return new Inlet(this);
    };

    Channel.prototype.out = function() {
      return new Outlet(this);
    };

    Channel.prototype.close = function(result) {
      var ref;
      switch (this.flags) {
        case 0:
        case 4:
        case 8:
        case 12:
          break;
        case 6:
        case 14:
          while (this.head) {
            this.dispatch(false, true);
          }
          break;
        case 9:
        case 13:
          if (this.buffer != null) {
            while (this.head) {
              this.dispatch(this.buffer.dequeue(), false);
            }
          }
          while (this.head) {
            this.dispatch(result, true);
          }
          break;
        case 16:
        case 20:
        case 24:
        case 28:
          return;
        default:
          throw new Error("Invalid channel state");
      }
      if ((ref = this.buffer) != null) {
        ref.close();
      }
      this.flags = this.flags & ~(PUSHED | PULLED) | CLOSED;
      return this.result = result;
    };

    Channel.prototype.enqueue = function(sender, value) {
      switch (this.flags) {
        case 0:
        case 8:
          this.buffer.enqueue(value);
          return sender.register(true, false);
        case 4:
        case 6:
        case 12:
        case 14:
          this.detain(sender, value);
          return false;
        case 9:
        case 13:
          if (this.buffer != null) {
            this.buffer.enqueue(value);
            while (!this.stateIsValid()) {
              this.dispatch(this.buffer.dequeue(), false);
            }
          } else {
            this.dispatch(value, false);
          }
          return sender.register(true, false);
        case 16:
        case 20:
        case 24:
        case 28:
          return sender.register(false, true);
        default:
          throw new Error("Invalid channel state");
      }
    };

    Channel.prototype.dequeue = function(receiver) {
      var done, value;
      switch (this.flags) {
        case 0:
        case 4:
        case 16:
        case 20:
          value = this.buffer.dequeue(this);
          break;
        case 6:
          value = this.buffer.dequeue(this);
          while (!this.stateIsValid()) {
            this.buffer.enqueue(this.dispatch(true, false));
          }
          break;
        case 8:
        case 9:
        case 12:
        case 13:
          this.detain(receiver);
          break;
        case 14:
          if (this.buffer != null) {
            while (this.flags === 14) {
              this.buffer.enqueue(this.dispatch(true, false));
            }
            return this.dequeue(receiver);
          } else {
            value = this.dispatch(true, false);
          }
          break;
        case 24:
        case 28:
          if (this.buffer != null) {
            this.buffer.free();
            this.buffer = null;
          }
          done = true;
          value = this.result;
          break;
        default:
          throw new Error("Invalid channel state");
      }
      return receiver.register(value, done || false);
    };

    Channel.prototype.detain = function(awaiter, value) {
      this.flags |= arguments.length < 2 ? PULLED : PUSHED;
      this.tail = (awaiter._prev = this.tail) ? this.tail._next = awaiter : this.head = awaiter;
      return awaiter.block(this, value);
    };

    Channel.prototype.dispatch = function(value, isFinal) {
      var awaiter;
      awaiter = this.head;
      if (this.head = awaiter._next) {
        this.head._prev = awaiter._next = null;
      } else {
        this.tail = null;
        this.flags &= ~(PUSHED | PULLED);
      }
      return awaiter.proceed(value, isFinal);
    };

    Channel.prototype.cancel = function(operation) {
      var _next, _prev;
      _prev = operation._prev, _next = operation._next;
      if (operation === this.head) {
        if (!(this.head = _next)) {
          this.flags &= ~(PUSHED | PULLED);
        }
      } else {
        if (_prev != null) {
          _prev._next = _next;
        }
      }
      if (operation === this.tail) {
        this.tail = _prev;
      } else {
        if (_next != null) {
          _next._prev = _prev;
        }
      }
      return operation._prev = operation._next = null;
    };

    Channel.prototype.toString = function() {
      var ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      return "[object Channel] {\n  id:     " + this.id + "\n  state:  " + (this.flagsToString()) + "\n  buffer: " + ((ref = typeof buffer !== "undefined" && buffer !== null ? (ref1 = buffer.queue) != null ? ref1.length : void 0 : void 0) != null ? ref : null) + "/" + ((ref2 = typeof buffer !== "undefined" && buffer !== null ? buffer.size : void 0) != null ? ref2 : null) + "\n  head:   " + ((ref3 = (ref4 = (ref5 = this.head) != null ? ref5.id : void 0) != null ? ref4 : (ref6 = this.head) != null ? ref6.constructor.name : void 0) != null ? ref3 : null) + "\n  tail:   " + ((ref7 = (ref8 = (ref9 = this.tail) != null ? ref9.id : void 0) != null ? ref8 : (ref10 = this.tail) != null ? ref10.constructor.name : void 0) != null ? ref7 : null) + "\n}";
    };

    Channel.prototype.flagsToString = function() {
      var flags, k, str, v;
      flags = {
        CLOSED: CLOSED,
        EMPTY: EMPTY,
        FULL: FULL,
        PUSHED: PUSHED,
        PULLED: PULLED
      };
      str = ((function() {
        var results;
        results = [];
        for (k in flags) {
          v = flags[k];
          if (this.flags & v) {
            results.push(k);
          }
        }
        return results;
      }).call(this)).join(' | ');
      return "(" + str + ")";
    };

    Channel.prototype.direction = function() {
      switch (this.flags & (PUSHED | PULLED)) {
        case 0:
          return '';
        case PUSHED:
          return '->';
        case PULLED:
          return '<-';
        default:
          return '!!';
      }
    };

    return Channel;

  })();

}).call(this);
