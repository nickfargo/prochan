// Generated by CoffeeScript 1.9.3
(function() {
  var Awaiter, Channel, Process, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Awaiter = require('./awaiter');

  Channel = require('./channel');

  Queue = require('./queue');

  module.exports = Process = (function(superClass) {
    var BATCH_SIZE, BLOCKED, ERROR, INCIPIENT, NO_OPTIONS, RUNNING, SCHEDULED, TERMINATED, batch, batchId, current, ioc, runqueue, schedule, table, uid;

    extend(Process, superClass);

    NO_OPTIONS = {};

    INCIPIENT = 0x01;

    SCHEDULED = 0x02;

    RUNNING = 0x04;

    BLOCKED = 0x08;

    TERMINATED = 0x10;

    ERROR = 0x20;

    BATCH_SIZE = 1024;

    uid = 0;

    current = null;

    batchId = null;

    table = {};

    runqueue = new Queue;

    function Process(options, generator) {
      var base;
      if (options == null) {
        options = NO_OPTIONS;
      }
      Process.__super__.constructor.apply(this, arguments);
      this.id = 'p' + ++uid;
      this.flags = INCIPIENT;
      this.parent = current;
      this.children = null;
      this.iterator = generator;
      this.cin = options["in"], this.cout = options.out;
      if (this.parent) {
        ((base = this.parent).children != null ? base.children : base.children = {})[this.id] = this;
      }
      table[this.id] = this;
    }

    schedule = function(p) {
      p.flags = SCHEDULED;
      runqueue.enqueue(p);
      if (batchId == null) {
        batchId = setImmediate(batch);
      }
    };

    batch = function() {
      var n;
      n = 0;
      while (runqueue.length) {
        ioc(runqueue.dequeue());
        if (++n >= BATCH_SIZE) {
          break;
        }
      }
      batchId = runqueue.length ? setImmediate(batch) : null;
    };

    ioc = function(p) {
      var done, error, ref, value;
      if (p.flags & TERMINATED) {
        return;
      }
      if (~p.flags & SCHEDULED) {
        p["throw"]();
      }
      p.flags = RUNNING;
      current = p;
      try {
        while (true) {
          ref = p.iterator.next(p.value), value = ref.value, done = ref.done;
          if (done) {
            p.exit(value);
          }
          if (~p.flags & RUNNING) {
            break;
          }
        }
      } catch (_error) {
        error = _error;
        p.kill(error);
      } finally {
        current = null;
      }
    };

    Process.spawn = function(options, generator, args) {
      var p;
      if (options == null) {
        throw new Error("Arity");
      }
      if (typeof options === 'function' || typeof options.next === 'function') {
        args = generator;
        generator = options;
        options = void 0;
      }
      if (typeof generator === 'function') {
        generator = generator.apply(this, args != null ? args : options != null ? options.args : void 0);
      }
      if (typeof generator.next !== 'function') {
        throw new Error("Invalid generator");
      }
      p = new Process(options, generator);
      p.proceed();
      return p;
    };

    Process.current = function() {
      if ((current != null ? current.flags : void 0) & RUNNING) {
        return current;
      } else {
        return Process["throw"]("Not in process", current);
      }
    };

    Process["throw"] = function(message, p) {
      if (message == null) {
        message = "<no message>";
      }
      if (p != null) {
        message = message + "\n---\nProcess:  " + p.id + "\nState:    (" + (p.flagsToString()) + ")";
      }
      throw new Error(message);
    };

    Process.list = function() {
      var id, p;
      return ((function() {
        var results;
        results = [];
        for (id in table) {
          p = table[id];
          results.push(p.toString());
        }
        return results;
      })()).join('\n');
    };

    Process.tree = function() {
      var id, p;
      return ((function() {
        var results;
        results = [];
        for (id in table) {
          p = table[id];
          if (p.parent == null) {
            results.push(p.toTree());
          }
        }
        return results;
      })()).join('');
    };

    Process.prototype["throw"] = function(message) {
      return Process["throw"](message, this);
    };

    Process.prototype._in = function() {
      return this.cin != null ? this.cin : this.cin = new Channel;
    };

    Process.prototype._out = function() {
      return this.cout != null ? this.cout : this.cout = new Channel;
    };

    Process.prototype["in"] = function() {
      return this._in()["in"]();
    };

    Process.prototype.out = function() {
      return this._out().out();
    };

    Process.prototype.canProcessReceive = function() {
      return (this.cin == null) || !!this.cin.canProcessReceive();
    };

    Process.prototype.canProcessSend = function() {
      return (this.cout == null) || !!this.cout.canProcessSend();
    };

    Process.prototype.isClosed = function() {
      var ref;
      return !!((ref = this.cin) != null ? ref.isClosed() : void 0);
    };

    Process.prototype.isDone = function() {
      var ref;
      return !!((ref = this.cout) != null ? ref.isDone() : void 0);
    };

    Process.prototype.enqueue = function(sender, value) {
      var ref;
      if (this.flags & TERMINATED) {
        return sender.register(false, true);
      } else {
        return (ref = this._in()).enqueue.apply(ref, arguments);
      }
    };

    Process.prototype.dequeue = function(receiver) {
      var ref;
      if (this.flags & TERMINATED && (this.cout == null)) {
        return receiver.register(this.value, true);
      } else {
        return (ref = this._out()).dequeue.apply(ref, arguments);
      }
    };

    Process.prototype.isScheduled = function() {
      return !!(this.flags & SCHEDULED);
    };

    Process.prototype.isRunning = function() {
      return !!(this.flags & RUNNING);
    };

    Process.prototype.isBlocked = function() {
      return !!(this.flags & BLOCKED);
    };

    Process.prototype.isTerminated = function() {
      return !!(this.flags & TERMINATED);
    };

    Process.prototype.block = function() {
      Process.__super__.block.apply(this, arguments);
      if (!(this.flags & RUNNING)) {
        this["throw"]();
      }
      this.flags = BLOCKED;
      return this;
    };

    Process.prototype.proceed = function(value, isFinal) {
      var prior;
      if (isFinal == null) {
        isFinal = false;
      }
      if (!(this.flags & (INCIPIENT | BLOCKED))) {
        this["throw"]();
      }
      this.awaitee = null;
      prior = this.value;
      this.register(value, isFinal);
      schedule(this);
      return prior;
    };

    Process.prototype.exit = function(value) {
      var child, pid, ref;
      if (this.children != null) {
        ref = this.children;
        for (pid in ref) {
          child = ref[pid];
          child.parent = null;
        }
        this.children = null;
      }
      return this.kill(null, value);
    };

    Process.prototype.kill = function(error, value) {
      var child, pid, ref, ref1, ref2, ref3;
      if (error == null) {
        error = null;
      }
      this.flags = TERMINATED;
      if (error != null) {
        this.flags |= ERROR;
        this.value = error;
      } else {
        this.value = value;
      }
      if ((ref = this.cin) != null) {
        if (typeof ref.close === "function") {
          ref.close();
        }
      }
      if ((ref1 = this.cout) != null) {
        ref1.close(value);
      }
      if (this.children != null) {
        ref2 = this.children;
        for (pid in ref2) {
          child = ref2[pid];
          child.kill(error, value);
        }
      }
      if ((ref3 = this.parent) != null) {
        delete ref3.children[this.id];
      }
      delete table[this.id];
      if (error != null) {
        console.log(error);
        throw error;
      }
      return value;
    };

    Process.prototype.toString = function() {
      var id, ref, ref1, ref2, ref3, ref4, ref5;
      return "[object Process] {\n  id:       " + this.id + "\n  state:    " + (this.flagsToString()) + "\n  parent:   " + ((ref = (ref1 = this.parent) != null ? ref1.id : void 0) != null ? ref : null) + "\n  children: [" + ((function() {
        var results;
        results = [];
        for (id in this.children) {
          results.push(id);
        }
        return results;
      }).call(this)) + "]\n  I/O:      " + ((ref2 = (ref3 = this.cin) != null ? ref3.id : void 0) != null ? ref2 : null) + "/" + ((ref4 = (ref5 = this.cout) != null ? ref5.id : void 0) != null ? ref4 : null) + "\n}";
    };

    Process.prototype.toJSON = function() {
      var id, ref, ref1, ref2, ref3, ref4, ref5;
      return JSON.stringify({
        type: "Process",
        id: this.id,
        state: this.flagsToString(),
        parent: (ref = (ref1 = this.parent) != null ? ref1.id : void 0) != null ? ref : null,
        children: (function() {
          var results;
          results = [];
          for (id in this.children) {
            results.push(id);
          }
          return results;
        }).call(this),
        IO: [(ref2 = (ref3 = this.cin) != null ? ref3.id : void 0) != null ? ref2 : null, (ref4 = (ref5 = this.cout) != null ? ref5.id : void 0) != null ? ref4 : null]
      });
    };

    Process.prototype.toTree = function(indent) {
      var id, p, ref, ref1, ref2, ref3, ref4, s;
      if (indent == null) {
        indent = 0;
      }
      s = "" + ('  '.repeat(indent)) + this.id + " " + (this.flagsToString());
      if (this.awaitee != null) {
        s += " " + (this.awaitee.direction()) + this.awaitee.id;
      }
      if ((this.cin != null) || (this.cout != null)) {
        s += " (" + ((ref = (ref1 = this.cin) != null ? ref1.id : void 0) != null ? ref : null) + "/" + ((ref2 = (ref3 = this.cout) != null ? ref3.id : void 0) != null ? ref2 : null) + ")";
      }
      s += "\n";
      ref4 = this.children;
      for (id in ref4) {
        p = ref4[id];
        s += p.toTree(indent + 1);
      }
      return s;
    };

    Process.prototype.flagsToString = function() {
      var flags, k, n, str, v;
      flags = {
        INCIPIENT: INCIPIENT,
        SCHEDULED: SCHEDULED,
        RUNNING: RUNNING,
        BLOCKED: BLOCKED,
        TERMINATED: TERMINATED,
        ERROR: ERROR
      };
      n = 0;
      str = ((function() {
        var results;
        n++;
        results = [];
        for (k in flags) {
          v = flags[k];
          if (this.flags & v) {
            results.push(k);
          }
        }
        return results;
      }).call(this)).join(' | ');
      if (n === 1) {
        return str;
      } else {
        return "(" + str + ")";
      }
    };

    return Process;

  })(Awaiter);

}).call(this);
