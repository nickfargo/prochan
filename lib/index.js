// Generated by CoffeeScript 1.9.2
(function() {
  var AbstractGenerator, Buffer, Callback, Channel, Multicast, Process, Selector, alias, chan, fn, go, i, len, mult, name, offer, poll, proc, receive, ref, ref1, select, send, sleep, slice, timeout,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice1 = [].slice;

  Process = require('./process');

  Channel = require('./channel');

  Buffer = require('./buffer');

  Selector = require('./selector');

  Callback = require('./callback');

  ref = require('./helpers'), alias = ref.alias, AbstractGenerator = ref.AbstractGenerator;

  slice = Array.prototype.slice;

  proc = function(generator, args) {
    return Process.spawn.apply(Process, arguments);
  };

  proc.async = (function() {
    var AsyncGenerator, async;
    AsyncGenerator = (function(superClass) {
      extend(AsyncGenerator, superClass);

      function AsyncGenerator(g, a, c) {
        AsyncGenerator.__super__.constructor.apply(this, arguments);
        this.generator = g;
        this.args = a;
        this.callback = c;
      }

      AsyncGenerator.prototype.next = function(input) {
        var error, output;
        switch (++this._step) {
          case 1:
            return this["yield"](receive(proc(this.generator, this.args)));
          case 2:
            try {
              output = this.callback(null, input);
            } catch (_error) {
              error = _error;
              this.callback(error);
            }
            return this["return"](output);
        }
      };

      return AsyncGenerator;

    })(AbstractGenerator);
    return async = function(generator) {
      return function(_) {
        var g;
        g = function() {
          var args, callback, i;
          args = 2 <= arguments.length ? slice1.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
          return new AsyncGenerator(generator, args, callback);
        };
        proc(g, arguments);
      };
    };
  })();

  (function() {
    var f, i, len, name, ref1;
    f = function(name) {
      return function() {
        var ref1;
        return (ref1 = Process.current())[name].apply(ref1, arguments);
      };
    };
    ref1 = "enqueue dequeue isClosed isDone canProcessReceive canProcessSend".split(/\s+/);
    for (i = 0, len = ref1.length; i < len; i++) {
      name = ref1[i];
      proc[name] = f(name);
    }
  })();

  proc.dump = Process.dump;

  go = function() {
    var p;
    p = Process.spawn.apply(Process, arguments);
    return p.out();
  };

  chan = function(buffer, transducer) {
    var ch;
    return ch = new Channel(buffer, transducer);
  };

  ref1 = ['fixed', 'sliding', 'dropping'];
  for (i = 0, len = ref1.length; i < len; i++) {
    name = ref1[i];
    fn = Buffer[name];
    chan[name] = (function(fn) {
      return function() {
        var rest, size;
        size = arguments[0], rest = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
        return chan.apply(null, [fn(size)].concat(slice1.call(rest)));
      };
    })(fn);
  }

  chan.single = function(transducer) {
    var callback, ch;
    ch = chan(null, transducer);
    receive.async(ch, callback = function(value) {
      if (ch.buffer != null) {
        ch.buffer.close();
        ch.buffer = null;
      }
      ch.flags |= 8;
      return ch.close(value);
    });
    return ch;
  };

  chan.isFinal = function() {
    return Process.current().isFinal;
  };

  receive = function() {
    var channel, p;
    p = Process.current();
    switch (arguments.length) {
      case 0:
        channel = p._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.dequeue(p);
  };

  receive.async = function(channel, fn) {
    var callback, done, immediate, result;
    callback = Callback.alloc(fn);
    done = channel.isDone();
    immediate = channel.canProcessReceive();
    result = channel.dequeue(callback);
    if (done || immediate) {
      callback.proceed(result, done);
    }
  };

  send = function() {
    var channel, p, value;
    p = Process.current();
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = p._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.enqueue(p, value);
  };

  send.async = function(channel, value, fn) {
    var callback, closed, immediate, result;
    callback = Callback.alloc(fn);
    closed = channel.isClosed();
    immediate = channel.canProcessSend();
    result = channel.enqueue(callback, value);
    if (closed || immediate) {
      callback.proceed(result, closed);
    }
    return !closed;
  };

  select = Selector.select;

  poll = function() {
    var channel;
    switch (arguments.length) {
      case 0:
        channel = Process.current()._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessReceive()) {
      return receive.async(channel);
    }
  };

  offer = function() {
    var channel, value;
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = Process.current()._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessSend()) {
      return send.async(channel, value);
    } else {
      return false;
    }
  };

  timeout = function() {
    var args, ch, fn, ms;
    ms = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice1.call(arguments, 2) : [];
    ch = chan();
    if (typeof ms === 'function') {
      fn = arguments[0], ms = arguments[1];
    }
    setTimeout(((function(_this) {
      return function() {
        return ch.close(fn != null ? fn.apply(_this, args) : void 0);
      };
    })(this)), ms);
    return ch.out();
  };

  sleep = function() {
    return receive(timeout.apply(null, arguments));
  };

  mult = function(channel) {
    return new Multicast(channel);
  };

  alias({
    single: 'promise'
  }, chan);

  alias({
    receive: 'get take',
    send: 'put',
    select: 'alts'
  }, select, module.exports = {
    proc: proc,
    chan: chan,
    go: go,
    receive: receive,
    send: send,
    select: select,
    poll: poll,
    offer: offer,
    timeout: timeout,
    sleep: sleep,
    mult: mult
  });

  Multicast = require('./multicast');

}).call(this);
