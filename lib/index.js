// Generated by CoffeeScript 1.9.2
(function() {
  var Buffer, Callback, Channel, Process, Selector, alias, chan, fn, go, i, len, name, offer, poll, proc, receive, ref, select, send, sleep, slice, timeout,
    slice1 = [].slice;

  Process = require('./process');

  Channel = require('./channel');

  Buffer = require('./buffer');

  Selector = require('./selector');

  Callback = require('./callback');

  alias = require('./helpers').alias;

  slice = Array.prototype.slice;

  proc = function() {
    var p;
    return p = Process.spawn.apply(Process, arguments);
  };

  proc.async = (function() {
    var AsyncIterator, async;
    AsyncIterator = (function() {
      function AsyncIterator(generator1, args1, callback1) {
        this.generator = generator1;
        this.args = args1;
        this.callback = callback1;
        this.step = 0;
        this.result = {
          value: void 0,
          done: false
        };
      }

      AsyncIterator.prototype.next = function(input) {
        var error, output;
        switch (++this.step) {
          case 1:
            output = receive(proc(this.generator, this.args));
            break;
          case 2:
            try {
              output = this.callback(null, input);
            } catch (_error) {
              error = _error;
              this.callback(error);
            }
            this.result.done = true;
        }
        this.result.value = output;
        return this.result;
      };

      return AsyncIterator;

    })();
    return async = function(generator) {
      return function(_) {
        var g;
        g = function() {
          var args, callback, i;
          args = 2 <= arguments.length ? slice1.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
          return new AsyncIterator(generator, args, callback);
        };
        proc(g, arguments);
      };
    };
  })();

  (function() {
    var f, i, len, name, ref;
    f = function(name) {
      return function() {
        var ref;
        return (ref = Process.current())[name].apply(ref, arguments);
      };
    };
    ref = "enqueue dequeue isClosed isDone canProcessReceive canProcessSend".split(/\s+/);
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      proc[name] = f(name);
    }
  })();

  proc.dump = Process.dump;

  go = function() {
    var p;
    p = Process.spawn.apply(Process, arguments);
    return p.out();
  };

  chan = function(buffer, transducer) {
    var ch;
    return ch = new Channel(buffer, transducer);
  };

  ref = ['fixed', 'sliding', 'dropping'];
  for (i = 0, len = ref.length; i < len; i++) {
    name = ref[i];
    fn = Buffer[name];
    chan[name] = (function(fn) {
      return function() {
        var rest, size;
        size = arguments[0], rest = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
        return chan.apply(null, [fn(size)].concat(slice1.call(rest)));
      };
    })(fn);
  }

  chan.single = function(transducer) {
    var callback, ch;
    ch = chan(null, transducer);
    receive.async(ch, callback = function(value) {
      if (ch.buffer != null) {
        ch.buffer.close();
        ch.buffer = null;
      }
      ch.flags |= 8;
      return ch.close(value);
    });
    return ch;
  };

  receive = function() {
    var channel, p;
    p = Process.current();
    switch (arguments.length) {
      case 0:
        channel = p._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.dequeue(p);
  };

  receive.async = function(channel, fn) {
    var callback, immediate, result;
    callback = Callback.alloc(channel, fn);
    immediate = channel.canProcessReceive();
    result = channel.dequeue(callback);
    if (immediate) {
      callback.proceed(result, channel.isDone());
    }
    return result;
  };

  send = function() {
    var channel, p, value;
    p = Process.current();
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = p._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.enqueue(p, value);
  };

  send.async = function(channel, value, fn) {
    var callback, immediate, result;
    callback = Callback.alloc(channel, fn);
    immediate = channel.canProcessSend();
    result = channel.enqueue(callback, value);
    if (immediate) {
      callback.proceed(result, channel.isClosed());
    }
    return result;
  };

  select = Selector.select;

  poll = function() {
    var channel;
    switch (arguments.length) {
      case 0:
        channel = Process.current()._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessReceive()) {
      return receive.async(channel);
    }
  };

  offer = function() {
    var channel, value;
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = Process.current()._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessSend()) {
      return send.async(channel, value);
    } else {
      return false;
    }
  };

  timeout = function() {
    var args, ch, fn, ms;
    ms = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice1.call(arguments, 2) : [];
    ch = chan();
    if (typeof ms === 'function') {
      fn = arguments[0], ms = arguments[1];
    }
    setTimeout(((function(_this) {
      return function() {
        return ch.close(fn != null ? fn.apply(_this, args) : void 0);
      };
    })(this)), ms);
    return ch.out();
  };

  sleep = function() {
    return receive(timeout.apply(null, arguments));
  };

  alias({
    single: 'promise'
  }, chan);

  alias({
    receive: 'get take',
    send: 'put',
    select: 'alts'
  }, select, module.exports = {
    proc: proc,
    chan: chan,
    go: go,
    receive: receive,
    send: send,
    select: select,
    poll: poll,
    offer: offer,
    timeout: timeout,
    sleep: sleep
  });

}).call(this);
