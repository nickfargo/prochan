// Generated by CoffeeScript 1.10.0
(function() {
  var assert, async, chan, expect, final, go, proc, receive, ref, ref1, select, send, sleep;

  ref = require('chai'), assert = ref.assert, expect = ref.expect;

  ref1 = require('prochan'), proc = ref1.proc, go = ref1.go, chan = ref1.chan, send = ref1.send, receive = ref1.receive, final = ref1.final, select = ref1.select, sleep = ref1.sleep;

  async = proc.async;

  describe("Demos:", function() {
    it("does go ping-pong", async(function*() {
      var Ball, ball, player, table;
      table = chan();
      Ball = function() {
        return this.hits = 0;
      };
      player = function*(name, table) {
        var ball, results;
        results = [];
        while (true) {
          ball = (yield receive(table));
          ball.hits++;
          (yield sleep(1));
          results.push((yield send(table, ball)));
        }
        return results;
      };
      proc(player('Ping ->', table));
      proc(player('<- Pong', table));
      (yield send(table, ball = new Ball));
      (yield sleep(20));
      return assert.equal(ball, (yield receive(table)));
    }));
    it("sieves the primes", async(function*() {
      var filtering, j, len, n, numbers, primes, ref2, sieve;
      numbers = function*(start) {
        var n;
        n = start;
        while (true) {
          (yield send(n++));
        }
      };
      filtering = function*(input, prime) {
        var n;
        while (true) {
          n = (yield receive(input));
          if (n % prime) {
            (yield send(n));
          }
        }
      };
      sieve = function*() {
        var prime, source;
        source = proc(numbers(2));
        while (true) {
          (yield send(prime = (yield receive(source))));
          source = proc(filtering(source, prime));
        }
      };
      primes = proc(sieve);
      ref2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
      for (j = 0, len = ref2.length; j < len; j++) {
        n = ref2[j];
        assert.equal(n, (yield receive(primes)));
      }
    }));
    return it("detects `done` without racing or sentinels", async(function*() {
      var c, consumers, i, j, len, producer, sanity;
      sanity = 10;
      producer = proc(function*() {
        var i, j;
        for (i = j = 1; j <= 10; i = ++j) {
          (yield send(i));
        }
        return 'foo';
      });
      consumers = (function() {
        var j, results;
        results = [];
        for (i = j = 1; j <= 3; i = ++j) {
          results.push(proc(function*() {
            var value;
            while (!final(value = (yield receive(producer)))) {
              if (sanity-- === 0) {
                throw new Error("Huge mistake");
              }
            }
            return value;
          }));
        }
        return results;
      })();
      for (j = 0, len = consumers.length; j < len; j++) {
        c = consumers[j];
        assert.equal('foo', (yield receive(c)));
      }
    }));
  });

  describe("chan.from", function() {
    it("correctly loads small arrays", function() {
      var ch;
      ch = chan.from([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
      return assert.equal(ch.buffer.queue.length, 10);
    });
    return it("correctly loads multi-cell size arrays", function() {
      var ch, j, q, results;
      ch = chan.from((function() {
        results = [];
        for (j = 1; j <= 72; j++){ results.push(j); }
        return results;
      }).apply(this));
      q = ch.buffer.queue;
      assert(q != null);
      assert.equal(q.head._next._next, q.tail);
      assert.equal(q.tail._prev._prev, q.head);
      return assert.equal(q.tail.array.length, 8);
    });
  });

  describe("Laziness:", function() {
    return it("allows eager-to-lazy communication", async(function*() {
      var channel, gobble, nibble, ref2, value;
      nibble = go(function*() {
        var src;
        src = chan.from([1, 2, 3]);
        return (yield receive(proc(function*() {
          var i, j, results, value;
          results = [];
          for (i = j = 1; j <= 3; i = ++j) {
            value = (yield receive(src));
            (yield proc);
            results.push(value);
          }
          return results;
        })));
      });
      gobble = go(function*() {
        var src;
        src = chan.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        return (yield receive(proc(function*() {
          var i, j, results;
          results = [];
          for (i = j = 1; j <= 9; i = ++j) {
            results.push((yield receive(src)));
          }
          return results;
        })));
      });
      ref2 = (yield* select(nibble, gobble)), value = ref2.value, channel = ref2.channel;
      return assert.equal(channel, gobble);
    }));
  });

}).call(this);
