// Generated by CoffeeScript 1.9.2
(function() {
  var AbstractGenerator, Multicast, chan, pooled, proc, receive, ref, ref1, send,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./'), proc = ref.proc, chan = ref.chan, receive = ref.receive, send = ref.send;

  ref1 = require('./helpers'), pooled = ref1.pooled, AbstractGenerator = ref1.AbstractGenerator;

  module.exports = Multicast = (function() {
    var MulticastGenerator, Relay;

    function Multicast(source) {
      this.source = source;
      this.relays = {};
      this.size = 0;
      this.completed = chan();
      this.remaining = 0;
      this.deliver = (function(_this) {
        return function(channel, stillOpen) {
          if (--_this.remaining === 0) {
            send.async(_this.completed);
          }
          if (!stillOpen) {
            return _this.remove(channel);
          }
        };
      })(this);
      proc(new MulticastGenerator(this));
    }

    MulticastGenerator = (function(superClass) {
      extend(MulticastGenerator, superClass);

      function MulticastGenerator(mult) {
        MulticastGenerator.__super__.constructor.apply(this, arguments);
        this.mult = mult;
      }

      MulticastGenerator.prototype.next = function(input) {
        var channel, id, ref2, ref3, relay, value;
        while (true) {
          switch (++this._step) {
            case 1:
              return this["yield"](receive(this.mult.source));
            case 2:
              value = input;
              if (this.mult.source.isDone()) {
                ref2 = this.mult.relays;
                for (id in ref2) {
                  relay = ref2[id];
                  if (relay.shouldClose) {
                    relay.channel.close(value);
                  }
                  relay.free();
                }
                this.mult.reset();
                return this["return"]();
              } else {
                this.mult.remaining = this.mult.size;
                ref3 = this.mult.relays;
                for (id in ref3) {
                  channel = ref3[id].channel;
                  send.async(channel, value, this.mult.deliver);
                }
                this._step = 0;
                if (this.mult.size > 0) {
                  return this["yield"](receive(this.mult.completed));
                }
              }
          }
        }
      };

      return MulticastGenerator;

    })(AbstractGenerator);

    pooled(Relay = (function() {
      function Relay(channel1, shouldClose1) {
        this.channel = channel1;
        this.shouldClose = shouldClose1;
      }

      return Relay;

    })());

    Multicast.prototype.add = function(channel, shouldClose) {
      var ch, ref2;
      if (shouldClose == null) {
        shouldClose = true;
      }
      ch = (ref2 = typeof channel._in === "function" ? channel._in() : void 0) != null ? ref2 : channel;
      if (this.relays[ch.id] == null) {
        this.size++;
      }
      this.relays[ch.id] = Relay.alloc(ch, shouldClose);
      return this;
    };

    Multicast.prototype.remove = function(channel) {
      var ch, ref2, relay;
      ch = (ref2 = typeof channel._in === "function" ? channel._in() : void 0) != null ? ref2 : channel;
      if (relay = this.relays[ch.id]) {
        relay.free();
        delete this.relays[ch.id];
        this.size--;
      }
      return this;
    };

    Multicast.prototype.reset = function() {
      this.relays = {};
      this.size = 0;
      return this;
    };

    return Multicast;

  })();

}).call(this);
