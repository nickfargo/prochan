// Generated by CoffeeScript 1.9.3
(function() {
  var assert, async, chan, comp, filter, final, map, mapcat, offer, poll, proc, receive, ref, ref1, send, takeWhile;

  assert = require('chai').assert;

  ref = require('prochan'), proc = ref.proc, chan = ref.chan, send = ref.send, receive = ref.receive, final = ref.final, poll = ref.poll, offer = ref.offer;

  async = proc.async;

  ref1 = require('transducers-js'), comp = ref1.comp, map = ref1.map, filter = ref1.filter, mapcat = ref1.mapcat, takeWhile = ref1.takeWhile;

  describe("Process:", function() {
    describe("I/O:", function() {
      return it("lets pass-through process act as a logical channel", async(function*() {
        var p1, p2, p3, p4, p5, p6, p7, p8, p9, pc;
        pc = proc(function*() {
          var value;
          while (true) {
            value = (yield receive());
            if (proc.isClosed()) {
              return value;
            } else {
              (yield send(value));
            }
          }
        });
        p1 = proc(function*() {
          return assert.equal(42, (yield receive(pc)));
        });
        p2 = proc(function*() {
          return (yield send(pc, 42));
        });
        (yield receive(p1));
        p3 = proc(function*() {
          return (yield send(pc, 42));
        });
        p4 = proc(function*() {
          return assert.equal(42, (yield receive(pc)));
        });
        (yield receive(p4));
        p5 = proc(function*() {
          return assert.equal(true, (yield send(pc, 42)));
        });
        p6 = proc(function*() {
          return (yield receive(pc));
        });
        (yield receive(p6));
        p7 = proc(function*() {
          return (yield receive(pc));
        });
        p8 = proc(function*() {
          return assert.equal(true, (yield send(pc, 42)));
        });
        (yield receive(p7));
        pc["in"]().close(1337);
        p9 = proc(function*() {
          return assert.equal(1337, (yield receive(pc)));
        });
        (yield receive(p9));
        assert.equal(true, pc.isClosed());
        return assert.equal(true, pc.isDone());
      }));
    });
    return describe("options:", function() {
      it("can specify I/O channels", async(function*() {
        var p1;
        p1 = proc({
          out: chan(1)
        }, function*() {
          var ref2;
          assert(((ref2 = p1.cout) != null ? ref2.buffer : void 0) != null);
          assert.equal(p1.cout.buffer.isEmpty(), true);
          (yield send(42));
          assert.equal(p1.cout.buffer.isEmpty(), false);
          (yield send(1337));
          return 'done';
        });
        return (yield receive(proc(function*() {
          assert.equal((yield receive(p1)), 42);
          assert.equal(p1.cout.buffer.isEmpty(), false);
          assert.equal((yield receive(p1)), 1337);
          assert.equal(p1.cout.buffer.isEmpty(), true);
          assert.equal((yield receive(p1)), 'done');
          assert(p1.isDone());
          assert.equal((yield receive(p1)), 'done');
        })));
      }));
      return it("can use other processes directly as I/O channels", async(function*() {
        var p, pin, pout;
        pin = proc(function*() {
          var i;
          i = 0;
          while (true) {
            (yield send(++i));
          }
        });
        pout = proc(function*() {
          var results, value;
          results = [];
          while (!final(value = (yield receive()))) {
            results.push((yield send(value.toString())));
          }
          return results;
        });
        p = proc({
          "in": pin,
          out: pout
        }, function*() {
          var results, value;
          results = [];
          while (!final(value = (yield receive()))) {
            results.push((yield send(value * 2)));
          }
          return results;
        });
        return (yield receive(proc(function*() {
          assert.equal((yield receive(p)), '2');
          assert.equal((yield receive(p)), '4');
          assert.equal((yield receive(pout)), '6');
          return assert.equal((yield receive(pout)), '8');
        })));
      }));
    });
  });

}).call(this);
