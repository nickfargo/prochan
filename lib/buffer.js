// Generated by CoffeeScript 1.9.2
(function() {
  var Buffer, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Queue = require('./queue');

  module.exports = Buffer = (function() {
    var EMPTY, FULL, mask;

    EMPTY = 0x08;

    FULL = 0x04;

    mask = EMPTY | FULL;

    function Buffer(size1, transducer) {
      this.size = size1;
      this.flags = this.size > 0 ? EMPTY : mask;
      this.queue = this.size != null ? new Queue : void 0;
      this.transform = typeof transducer === "function" ? transducer(this) : void 0;
      this.channel = null;
    }

    Buffer.prototype['@@transducer/result'] = function(b) {
      return b;
    };

    Buffer.prototype['@@transducer/step'] = function(b, x) {
      b.queue.enqueue(x);
      return b;
    };

    Buffer.prototype.isEmpty = function() {
      return this.queue.length === 0;
    };

    Buffer.prototype.isFull = function() {
      return this.queue.length >= this.size;
    };

    Buffer.prototype.ingest = function(input) {
      var result;
      if (this.transform != null) {
        result = this.transform['@@transducer/step'](this, input);
        if (result != null ? result['@@transducer/reduced'] : void 0) {
          this.channel.close();
        }
        return result;
      } else {
        this.queue.enqueue(input);
        return input;
      }
    };

    Buffer.prototype.update = function() {
      this.flags = (this.isEmpty() ? EMPTY : 0) | (this.isFull() ? FULL : 0);
      this.channel.flags = this.channel.flags & ~mask | this.flags & mask;
    };

    Buffer.prototype.close = function() {
      var ref;
      if ((ref = this.transform) != null) {
        ref['@@transducer/result'](this);
      }
    };

    Buffer.prototype.enqueue = function(input) {
      if (!(!this.isFull() || this.size === 0)) {
        throw new Error;
      }
      this.ingest(input);
      this.update();
      return true;
    };

    Buffer.prototype.dequeue = function() {
      var value;
      if (!!this.isEmpty()) {
        throw new Error;
      }
      value = this.queue.dequeue();
      this.update();
      return value;
    };

    Buffer.Sliding = (function(superClass) {
      extend(Sliding, superClass);

      function Sliding() {
        return Sliding.__super__.constructor.apply(this, arguments);
      }

      Sliding.prototype.isFull = function() {
        return false;
      };

      Sliding.prototype.enqueue = function(input) {
        this.ingest(input);
        while (this.queue.length > this.size) {
          this.queue.dequeue();
        }
        this.update();
        return true;
      };

      return Sliding;

    })(Buffer);

    Buffer.Dropping = (function(superClass) {
      extend(Dropping, superClass);

      function Dropping() {
        return Dropping.__super__.constructor.apply(this, arguments);
      }

      Dropping.prototype.isFull = function() {
        return false;
      };

      Dropping.prototype.enqueue = function(input) {
        if (this.queue.length < this.size) {
          this.ingest(input);
          this.update();
          return true;
        } else {
          return false;
        }
      };

      return Dropping;

    })(Buffer);

    Buffer.fixed = function(size, transducer) {
      return new Buffer(size, transducer);
    };

    Buffer.sliding = function(size, transducer) {
      return new Buffer.Sliding(size, transducer);
    };

    Buffer.dropping = function(size, transducer) {
      return new Buffer.Dropping(size, transducer);
    };

    return Buffer;

  })();

}).call(this);
