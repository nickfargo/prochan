// Generated by CoffeeScript 1.9.3
(function() {
  var Operation, Process, Selector, isArray,
    slice = [].slice;

  Process = require('./process');

  Operation = require('./operation');

  isArray = require('./helpers').isArray;

  module.exports = Selector = (function() {
    var ACTIVATED, COMMITTED, COMPLETED, IMMEDIATE, INCIPIENT, Receive, Send, clear, commit, complete, delegable, destructure, first, iterate, last, randomly;

    Receive = Operation.Receive, Send = Operation.Send;

    INCIPIENT = 0x01;

    ACTIVATED = 0x02;

    COMMITTED = 0x04;

    COMPLETED = 0x08;

    IMMEDIATE = 0x10;

    Selector.prototype[(typeof Symbol !== "undefined" && Symbol !== null ? Symbol.iterator : void 0) || '@@iterator'] = function() {
      return this;
    };

    function Selector() {
      this.flags = INCIPIENT;
      this.process = Process.current();
      this.operations = [];
      this.alternative = null;
      this.arbiter = null;
      this.delegate = null;
      this.value = void 0;
    }

    first = function(a) {
      return a[0];
    };

    last = function(a) {
      return a[a.length - 1];
    };

    randomly = function(a) {
      return a[Math.random() * a.length | 0];
    };

    delegable = function(label) {
      if (typeof label === 'function') {
        return label;
      } else {
        return function(value, channel) {
          return {
            next: function() {
              return {
                value: {
                  label: label,
                  value: value,
                  channel: channel
                },
                done: true
              };
            }
          };
        };
      }
    };

    destructure = (function() {
      var out;
      out = [];
      return destructure = function() {
        var args, consequent, i;
        args = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), consequent = arguments[i++];
        switch (typeof consequent) {
          case 'function':
            break;
          case 'string':
            consequent = delegable(consequent);
            break;
          default:
            args.push(consequent);
            consequent = delegable();
        }
        out[0] = args;
        out[1] = consequent;
        return out;
      };
    })();

    commit = function(s, operation, value) {
      if (s.flags & COMMITTED) {
        throw new Error("Already committed");
      }
      s.flags |= COMMITTED;
      if (operation != null) {
        if (operation.selector !== s) {
          throw new Error("Foreign operation");
        }
        s.value = operation.value;
        s.delegate = operation.consequent(value, operation.channel);
      } else {
        s.delegate = s.alternative();
      }
      clear(s);
      s.alternative = null;
      s.arbiter = null;
    };

    clear = function(s) {
      var i, len, op, ref;
      ref = s.operations;
      for (i = 0, len = ref.length; i < len; i++) {
        op = ref[i];
        op.free();
      }
      s.operations.length = 0;
    };

    iterate = function(s, value) {
      var iteration;
      iteration = s.delegate.next(value);
      if (iteration.done) {
        complete(s);
      }
      return iteration;
    };

    complete = function(s) {
      s.flags = COMPLETED;
      s.process = null;
      s.delegate = null;
      return s.value = void 0;
    };

    Selector.select = function() {
      var consequent, i, len, op, operations, ref, s;
      ref = destructure.apply(null, arguments), operations = ref[0], consequent = ref[1];
      s = new Selector;
      for (i = 0, len = operations.length; i < len; i++) {
        op = operations[i];
        if (isArray(op)) {
          s.send(op, consequent);
        } else {
          s.receive(op, consequent);
        }
      }
      return s;
    };

    Selector.select.receive = function() {
      var ref;
      return (ref = new Selector).receive.apply(ref, arguments);
    };

    Selector.select.send = function() {
      var ref;
      return (ref = new Selector).send.apply(ref, arguments);
    };

    Selector.select.first = function() {
      return (new Selector).arbitrate(first);
    };

    Selector.select.last = function() {
      return (new Selector).arbitrate(last);
    };

    Selector.prototype.receive = function() {
      var channel, channels, consequent, i, len, ready, ref;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), channels = ref[0], consequent = ref[1];
      for (i = 0, len = channels.length; i < len; i++) {
        channel = channels[i];
        if (!(channel != null)) {
          continue;
        }
        ready = channel.canProcessReceive();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Receive.alloc(this, consequent, channel));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            clear(this);
          }
          this.operations.push(Receive.alloc(this, consequent, channel));
        }
      }
      return this;
    };

    Selector.prototype.send = function() {
      var channel, consequent, i, len, pairs, ready, ref, ref1, value;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), pairs = ref[0], consequent = ref[1];
      for (i = 0, len = pairs.length; i < len; i++) {
        ref1 = pairs[i], channel = ref1[0], value = ref1[1];
        if (!(channel != null)) {
          continue;
        }
        ready = channel.canProcessSend();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Send.alloc(this, consequent, channel, value));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            clear(this);
          }
          this.operations.push(Send.alloc(this, consequent, channel, value));
        }
      }
      return this;
    };

    Selector.prototype["else"] = function(alternative) {
      if (~this.flags & INCIPIENT) {
        throw new Error("Early");
      }
      this.flags &= ~INCIPIENT;
      if (this.flags & ACTIVATED || (this.alternative != null)) {
        throw new Error("Late");
      }
      this.alternative = delegable(alternative);
      return this;
    };

    Selector.prototype.arbitrate = function(arbiter) {
      if (this.flags & ACTIVATED || (this.arbiter != null)) {
        throw new Error("Late");
      }
      this.arbiter = arbiter;
      return this;
    };

    Selector.prototype.next = function(value) {
      var i, len, op, ref;
      if (~this.flags & ACTIVATED) {
        this.flags = this.flags & ~INCIPIENT | ACTIVATED;
        if (this.flags & IMMEDIATE) {
          op = (this.arbiter || randomly)(this.operations);
        }
        if (op != null) {
          if (op.type === 'send') {
            value = !op.channel.isClosed();
          }
          commit(this, op, value);
          return iterate(this, value);
        } else if (this.alternative) {
          commit(this);
          return iterate(this);
        } else {
          this.process.block(this);
          ref = this.operations;
          for (i = 0, len = ref.length; i < len; i++) {
            op = ref[i];
            op.detain();
          }
          return {
            value: void 0,
            done: false
          };
        }
      } else {
        return iterate(this, value);
      }
    };

    Selector.prototype.proceedWith = function(operation, value, isFinal) {
      commit(this, operation, value);
      this.flags |= ACTIVATED;
      this.process.value = this.value;
      return this.process.proceed(value, isFinal);
    };

    return Selector;

  })();

}).call(this);
