(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.prochan = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Awaiter;

  module.exports = Awaiter = (function() {
    function Awaiter() {
      this.awaitee = null;
      this._prev = null;
      this._next = null;
      this.value = void 0;
      this.isFinal = false;
    }

    Awaiter.prototype.block = function(awaitee, value) {};

    Awaiter.prototype.proceed = function(value, isFinal) {};

    return Awaiter;

  })();

}).call(this);

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Buffer, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Queue = require('./queue');

  module.exports = Buffer = (function() {
    var EMPTY, FULL, mask;

    EMPTY = 0x08;

    FULL = 0x04;

    mask = EMPTY | FULL;

    function Buffer(size1, transducer) {
      this.size = size1;
      this.flags = this.size > 0 ? EMPTY : mask;
      this.queue = this.size != null ? new Queue : void 0;
      this.transform = typeof transducer === "function" ? transducer(this) : void 0;
      this.channel = null;
    }

    Buffer.prototype['@@transducer/result'] = function(b) {
      return b;
    };

    Buffer.prototype['@@transducer/step'] = function(b, x) {
      b.queue.enqueue(x);
      return b;
    };

    Buffer.prototype.isEmpty = function() {
      return this.queue.length === 0;
    };

    Buffer.prototype.isFull = function() {
      return this.queue.length >= this.size;
    };

    Buffer.prototype.ingest = function(input) {
      var result;
      if (this.transform != null) {
        result = this.transform['@@transducer/step'](this, input);
        if (result != null ? result['@@transducer/reduced'] : void 0) {
          this.channel.close();
        }
        return result;
      } else {
        this.queue.enqueue(input);
        return input;
      }
    };

    Buffer.prototype.update = function() {
      this.flags = (this.isEmpty() ? EMPTY : 0) | (this.isFull() ? FULL : 0);
      this.channel.flags = this.channel.flags & ~mask | this.flags & mask;
    };

    Buffer.prototype.close = function() {
      var ref;
      if ((ref = this.transform) != null) {
        ref['@@transducer/result'](this);
      }
    };

    Buffer.prototype.enqueue = function(input) {
      if (!(!this.isFull() || this.size === 0)) {
        throw new Error;
      }
      this.ingest(input);
      this.update();
      return true;
    };

    Buffer.prototype.dequeue = function() {
      var value;
      if (!!this.isEmpty()) {
        throw new Error;
      }
      value = this.queue.dequeue();
      this.update();
      return value;
    };

    Buffer.Sliding = (function(superClass) {
      extend(Sliding, superClass);

      function Sliding() {
        return Sliding.__super__.constructor.apply(this, arguments);
      }

      Sliding.prototype.isFull = function() {
        return false;
      };

      Sliding.prototype.enqueue = function(input) {
        this.ingest(input);
        while (this.queue.length > this.size) {
          this.queue.dequeue();
        }
        this.update();
        return true;
      };

      return Sliding;

    })(Buffer);

    Buffer.Dropping = (function(superClass) {
      extend(Dropping, superClass);

      function Dropping() {
        return Dropping.__super__.constructor.apply(this, arguments);
      }

      Dropping.prototype.isFull = function() {
        return false;
      };

      Dropping.prototype.enqueue = function(input) {
        if (this.queue.length < this.size) {
          this.ingest(input);
          this.update();
          return true;
        } else {
          return false;
        }
      };

      return Dropping;

    })(Buffer);

    Buffer.fixed = function(size, transducer) {
      return new Buffer(size, transducer);
    };

    Buffer.sliding = function(size, transducer) {
      return new Buffer.Sliding(size, transducer);
    };

    Buffer.dropping = function(size, transducer) {
      return new Buffer.Dropping(size, transducer);
    };

    return Buffer;

  })();

}).call(this);

},{"./queue":8}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Awaiter, Callback, pooled,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  pooled = require('./helpers').pooled;

  Awaiter = require('./awaiter');

  module.exports = pooled(Callback = (function(superClass) {
    extend(Callback, superClass);

    function Callback(channel, fn, context) {
      Callback.__super__.constructor.apply(this, arguments);
      this.channel = channel;
      this.fn = fn;
      this.context = context;
    }

    Callback.prototype.proceed = function(value, isFinal) {
      var ref, result;
      result = (ref = this.fn) != null ? ref.call(this.context, this.channel, value, isFinal) : void 0;
      this.free();
      return result;
    };

    return Callback;

  })(Awaiter));

}).call(this);

},{"./awaiter":1,"./helpers":5}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Buffer, Channel, attenuate;

  attenuate = require('./helpers').attenuate;

  Buffer = require('./buffer');

  module.exports = Channel = (function() {
    var CLOSED, EMPTY, FULL, Inlet, Outlet, PULLED, PUSHED, uid;

    uid = 0;

    CLOSED = 0x10;

    EMPTY = 0x08;

    FULL = 0x04;

    PUSHED = 0x02;

    PULLED = 0x01;

    function Channel(buffer, transducer) {
      var ref;
      this.id = 'ch' + ++uid;
      this.buffer = null;
      if ((buffer != null) || (transducer != null)) {
        switch (typeof buffer) {
          case 'number':
            this.buffer = new Buffer(buffer, transducer);
            break;
          case 'string':
            this.buffer = Buffer[buffer](1, transducer);
            break;
          case 'function':
            transducer = buffer;
            this.buffer = new Buffer(0, transducer);
            break;
          default:
            this.buffer = buffer != null ? buffer : new Buffer(0, transducer);
        }
        this.buffer.channel = this;
      }
      this.flags = ((ref = this.buffer) != null ? ref.size : void 0) > 0 ? EMPTY : EMPTY | FULL;
      this.head = null;
      this.tail = null;
      this.result = void 0;
    }

    Inlet = (function() {
      function Inlet() {}

      Inlet = attenuate('enqueue detain cancel canProcessSend isClosed close');

      Inlet.prototype["in"] = function() {
        return this;
      };

      return Inlet;

    })();

    Outlet = (function() {
      function Outlet() {}

      Outlet = attenuate('dequeue detain cancel canProcessReceive isDone');

      Outlet.prototype.out = function() {
        return this;
      };

      return Outlet;

    })();

    Channel.prototype.stateIsValid = function() {
      return 1 << this.flags & 0x11117351;
    };

    Channel.prototype.canProcessSend = function() {
      return 1 << this.flags & 0x00002301;
    };

    Channel.prototype.canProcessReceive = function() {
      return 1 << this.flags & 0x00114051;
    };

    Channel.prototype.isClosed = function() {
      return 1 << this.flags & 0x11110000;
    };

    Channel.prototype.isDone = function() {
      return 1 << this.flags & 0x11000000;
    };

    Channel.prototype["in"] = function() {
      return new Inlet(this);
    };

    Channel.prototype.out = function() {
      return new Outlet(this);
    };

    Channel.prototype.close = function(result) {
      var ref;
      switch (this.flags) {
        case 0:
        case 4:
        case 8:
        case 12:
          break;
        case 6:
        case 14:
          while (this.head) {
            this.dispatch(false, true);
          }
          break;
        case 9:
        case 13:
          if (this.buffer != null) {
            while (this.head) {
              this.dispatch(this.buffer.dequeue(), false);
            }
          }
          while (this.head) {
            this.dispatch(result, true);
          }
          break;
        case 16:
        case 20:
        case 24:
        case 28:
          return;
        default:
          throw new Error("Invalid channel state");
      }
      if ((ref = this.buffer) != null) {
        ref.close();
      }
      this.flags = this.flags & ~(PUSHED | PULLED) | CLOSED;
      return this.result = result;
    };

    Channel.prototype.enqueue = function(sender, value) {
      switch (this.flags) {
        case 0:
        case 8:
          this.buffer.enqueue(value);
          return sender.value = true;
        case 4:
        case 6:
        case 12:
        case 14:
          this.detain(sender, value);
          return false;
        case 9:
        case 13:
          if (this.buffer != null) {
            this.buffer.enqueue(value);
            while (!this.stateIsValid()) {
              this.dispatch(this.buffer.dequeue(), false);
            }
          } else {
            this.dispatch(value, false);
          }
          return sender.value = true;
        case 16:
        case 20:
        case 24:
        case 28:
          return sender.value = false;
        default:
          throw new Error("Invalid channel state");
      }
    };

    Channel.prototype.dequeue = function(receiver) {
      var value;
      switch (this.flags) {
        case 0:
        case 4:
        case 16:
        case 20:
          value = this.buffer.dequeue(this);
          break;
        case 6:
          value = this.buffer.dequeue(this);
          while (!this.stateIsValid()) {
            this.buffer.enqueue(this.dispatch(true, false));
          }
          break;
        case 8:
        case 9:
        case 12:
        case 13:
          this.detain(receiver);
          break;
        case 14:
          if (this.buffer != null) {
            while (this.flags === 14) {
              this.buffer.enqueue(this.dispatch(true, false));
            }
            return this.dequeue(receiver);
          } else {
            value = this.dispatch(true, false);
          }
          break;
        case 24:
        case 28:
          if (this.buffer != null) {
            this.buffer.free();
            this.buffer = null;
          }
          value = this.result;
          break;
        default:
          throw new Error("Invalid channel state");
      }
      return receiver.value = value;
    };

    Channel.prototype.detain = function(awaiter, value) {
      this.flags |= arguments.length < 2 ? PULLED : PUSHED;
      this.tail = (awaiter._prev = this.tail) ? this.tail._next = awaiter : this.head = awaiter;
      return awaiter.block(this, value);
    };

    Channel.prototype.dispatch = function(value, isFinal) {
      var awaiter;
      awaiter = this.head;
      if (this.head = awaiter._next) {
        this.head._prev = awaiter._next = null;
      } else {
        this.tail = null;
        this.flags &= ~(PUSHED | PULLED);
      }
      return awaiter.proceed(value, isFinal);
    };

    Channel.prototype.cancel = function(operation) {
      var _next, _prev;
      _prev = operation._prev, _next = operation._next;
      if (operation === this.head) {
        if (!(this.head = _next)) {
          this.flags &= ~(PUSHED | PULLED);
        }
      } else {
        if (_prev != null) {
          _prev._next = _next;
        }
      }
      if (operation === this.tail) {
        this.tail = _prev;
      } else {
        if (_next != null) {
          _next._prev = _prev;
        }
      }
      return operation._prev = operation._next = null;
    };

    Channel.prototype.toString = function() {
      var ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
      return "[object Channel] {\n  id:     " + this.id + "\n  state:  " + (this.flagsToString()) + "\n  buffer: " + ((ref = typeof buffer !== "undefined" && buffer !== null ? (ref1 = buffer.queue) != null ? ref1.length : void 0 : void 0) != null ? ref : null) + "/" + ((ref2 = typeof buffer !== "undefined" && buffer !== null ? buffer.size : void 0) != null ? ref2 : null) + "\n  head:   " + ((ref3 = (ref4 = (ref5 = this.head) != null ? ref5.id : void 0) != null ? ref4 : (ref6 = this.head) != null ? ref6.constructor.name : void 0) != null ? ref3 : null) + "\n  tail:   " + ((ref7 = (ref8 = (ref9 = this.tail) != null ? ref9.id : void 0) != null ? ref8 : (ref10 = this.tail) != null ? ref10.constructor.name : void 0) != null ? ref7 : null) + "\n}";
    };

    Channel.prototype.flagsToString = function() {
      var flags, k, str, v;
      flags = {
        CLOSED: CLOSED,
        EMPTY: EMPTY,
        FULL: FULL,
        PUSHED: PUSHED,
        PULLED: PULLED
      };
      str = ((function() {
        var results;
        results = [];
        for (k in flags) {
          v = flags[k];
          if (this.flags & v) {
            results.push(k);
          }
        }
        return results;
      }).call(this)).join(' | ');
      return "(" + str + ")";
    };

    Channel.prototype.direction = function() {
      switch (this.flags & (PUSHED | PULLED)) {
        case 0:
          return '';
        case PUSHED:
          return '->';
        case PULLED:
          return '<-';
        default:
          return '!!';
      }
    };

    return Channel;

  })();

}).call(this);

},{"./buffer":2,"./helpers":5}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var slice = [].slice;

  module.exports = (function() {
    var AbstractGenerator, has, ref;
    has = Object.prototype.hasOwnProperty;
    return {
      isArray: (ref = Array.isArray) != null ? ref : function(a) {
        return (a != null) && typeof a === 'object' && typeof a.splice === 'function' && typeof a.length === number;
      },
      alias: function() {
        var i, j, len, len1, map, o, objects, ref1, s, t;
        map = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        for (i = 0, len = objects.length; i < len; i++) {
          o = objects[i];
          for (s in map) {
            t = map[s];
            if (has.call(o, s)) {
              ref1 = t.split(/\s+/);
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                t = ref1[j];
                if (!has.call(o, t)) {
                  o[t] = o[s];
                }
              }
            }
          }
        }
      },
      pooled: function(constructor) {
        constructor.POOL_SIZE = 4096;
        constructor.pool = [];
        constructor.alloc = function() {
          var instance;
          if (!has.call(this, 'pool')) {
            this.pool = [];
          }
          instance = this.pool.pop() || new this;
          this.apply(instance, arguments);
          return instance;
        };
        constructor.prototype.free = (function() {
          var free, ref1, ref2, super__;
          free = function() {
            var c;
            c = this.constructor;
            c.apply(this, arguments);
            if (c.pool.length < c.POOL_SIZE) {
              return c.pool.push(this);
            }
          };
          super__ = (ref1 = (ref2 = constructor.__super__) != null ? ref2 : typeof constructor.prototype === "function" ? constructor.prototype(constructor.prototype) : void 0) != null ? ref1.free : void 0;
          if (super__ != null) {
            return function() {
              super__.apply(this, arguments);
              return free.apply(this, arguments);
            };
          } else {
            return free;
          }
        })();
        return constructor;
      },
      attenuate: function(methodNames) {
        var Attenuator, i, includes, len, name;
        if (typeof methodNames === 'string') {
          methodNames = methodNames.split(/\s+/);
        }
        includes = {};
        for (i = 0, len = methodNames.length; i < len; i++) {
          name = methodNames[i];
          includes[name] = true;
        }
        return Attenuator = (function() {
          var fn, j, len1;

          function Attenuator(client) {
            this['@@attenuator'] = function(name, args) {
              var result;
              if (includes[name] == null) {
                throw new TypeError;
              }
              result = client[name].apply(client, args);
              if (result === client) {
                return this;
              } else {
                return result;
              }
            };
          }

          fn = function(name) {
            return Attenuator.prototype[name] = function() {
              return this['@@attenuator'](name, arguments);
            };
          };
          for (j = 0, len1 = methodNames.length; j < len1; j++) {
            name = methodNames[j];
            fn(name);
          }

          return Attenuator;

        })();
      },
      AbstractGenerator: AbstractGenerator = (function() {
        function AbstractGenerator() {
          this._result = {
            value: void 0,
            done: false
          };
          this._step = 0;
        }

        AbstractGenerator.prototype["yield"] = function(value) {
          this._result.value = value;
          return this._result;
        };

        AbstractGenerator.prototype.next = function() {
          return this["return"]();
        };

        AbstractGenerator.prototype["return"] = function(value) {
          this._result.done = true;
          return this["yield"](value);
        };

        AbstractGenerator.prototype["throw"] = function(error) {
          throw error;
        };

        return AbstractGenerator;

      })()
    };
  })();

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Awaiter, Operation, pooled,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Awaiter = require('./awaiter');

  pooled = require('./helpers').pooled;

  module.exports = Operation = (function(superClass) {
    extend(Operation, superClass);

    function Operation(selector, consequent, channel, value) {
      Operation.__super__.constructor.apply(this, arguments);
      this.selector = selector;
      this.consequent = consequent;
      this.channel = channel;
      this.value = value;
    }

    Operation.prototype.proceed = function(value, isFinal) {
      return this.selector.proceedWith(this, value, isFinal);
    };

    Operation.prototype.free = function() {
      return this.channel.cancel(this);
    };

    pooled(Operation.Receive = (function(superClass1) {
      extend(Receive, superClass1);

      function Receive() {
        return Receive.__super__.constructor.apply(this, arguments);
      }

      Receive.prototype.type = 'receive';

      Receive.prototype.isReady = function() {
        return this.channel.canProcessReceive();
      };

      Receive.prototype.detain = function() {
        return this.channel.detain(this);
      };

      return Receive;

    })(Operation));

    pooled(Operation.Send = (function(superClass1) {
      extend(Send, superClass1);

      function Send() {
        return Send.__super__.constructor.apply(this, arguments);
      }

      Send.prototype.type = 'send';

      Send.prototype.isReady = function() {
        return this.channel.canProcessSend();
      };

      Send.prototype.detain = function() {
        return this.channel.detain(this, this.value);
      };

      return Send;

    })(Operation));

    return Operation;

  })(Awaiter);

}).call(this);

},{"./awaiter":1,"./helpers":5}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Awaiter, Channel, Process, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Awaiter = require('./awaiter');

  Channel = require('./channel');

  Queue = require('./queue');

  module.exports = Process = (function(superClass) {
    var BATCH_SIZE, BLOCKED, ERROR, INCIPIENT, RUNNING, SCHEDULED, TERMINATED, batch, batchId, current, ioc, runqueue, schedule, table, uid;

    extend(Process, superClass);

    INCIPIENT = 0x01;

    SCHEDULED = 0x02;

    RUNNING = 0x04;

    BLOCKED = 0x08;

    TERMINATED = 0x10;

    ERROR = 0x20;

    BATCH_SIZE = 1024;

    uid = 0;

    current = null;

    batchId = null;

    table = {};

    runqueue = new Queue;

    function Process(generator, args) {
      var base;
      Process.__super__.constructor.apply(this, arguments);
      this.id = 'p' + ++uid;
      if (this.parent = current) {
        ((base = this.parent).children != null ? base.children : base.children = {})[this.id] = this;
      }
      this.children = null;
      this.flags = INCIPIENT;
      if (typeof generator === 'function') {
        generator = generator.apply(this, args);
      }
      if (typeof generator.next !== 'function') {
        throw new Error("Invalid generator");
      }
      this.iterator = generator;
      this.cin = null;
      this.cout = null;
      table[this.id] = this;
    }

    schedule = function(p) {
      p.flags = SCHEDULED;
      runqueue.enqueue(p);
      if (batchId == null) {
        batchId = setImmediate(batch);
      }
    };

    batch = function() {
      var n;
      n = 0;
      while (runqueue.length) {
        ioc(runqueue.dequeue());
        if (++n >= BATCH_SIZE) {
          break;
        }
      }
      batchId = runqueue.length ? setImmediate(batch) : null;
    };

    ioc = function(p) {
      var done, error, ref, value;
      if (p.flags & TERMINATED) {
        return;
      }
      if (~p.flags & SCHEDULED) {
        p["throw"]();
      }
      p.flags = RUNNING;
      current = p;
      try {
        while (true) {
          ref = p.iterator.next(p.value), value = ref.value, done = ref.done;
          if (done) {
            p.exit(value);
          }
          if (~p.flags & RUNNING) {
            break;
          }
        }
      } catch (_error) {
        error = _error;
        p.kill(error);
      } finally {
        current = null;
      }
    };

    Process.spawn = function(generator, args) {
      var p;
      if (arguments.length === 0) {
        throw new Error("Arity");
      }
      p = new Process(generator, args);
      p.proceed();
      return p;
    };

    Process.current = function() {
      if ((current != null ? current.flags : void 0) & RUNNING) {
        return current;
      } else {
        return Process["throw"]("Not in process", current);
      }
    };

    Process["throw"] = function(message, p) {
      if (message == null) {
        message = "<no message>";
      }
      if (p != null) {
        message = message + "\n---\nProcess:  " + p.id + "\nState:    (" + (p.flagsToString()) + ")";
      }
      throw new Error(message);
    };

    Process.dump = function(style) {
      var id, p;
      if (style == null) {
        style = 'list';
      }
      switch (style) {
        case 'list':
          return ((function() {
            var results;
            results = [];
            for (id in table) {
              p = table[id];
              results.push(p.toString());
            }
            return results;
          })()).join('\n');
        case 'tree':
          return ((function() {
            var results;
            results = [];
            for (id in table) {
              p = table[id];
              if (p.parent === null) {
                results.push(p.toTree());
              }
            }
            return results;
          })()).join('');
      }
    };

    Process.prototype["throw"] = function(message) {
      return Process["throw"](message, this);
    };

    Process.prototype._in = function() {
      return this.cin != null ? this.cin : this.cin = new Channel;
    };

    Process.prototype._out = function() {
      return this.cout != null ? this.cout : this.cout = new Channel;
    };

    Process.prototype["in"] = function() {
      return this._in()["in"]();
    };

    Process.prototype.out = function() {
      return this._out().out();
    };

    Process.prototype.canProcessReceive = function() {
      var ref;
      return !!((ref = this.cin) != null ? ref.canProcessReceive() : void 0);
    };

    Process.prototype.canProcessSend = function() {
      var ref;
      return !!((ref = this.cout) != null ? ref.canProcessSend() : void 0);
    };

    Process.prototype.isClosed = function() {
      var ref;
      return !!((ref = this.cin) != null ? ref.isClosed() : void 0);
    };

    Process.prototype.isDone = function() {
      var ref;
      return !!((ref = this.cout) != null ? ref.isDone() : void 0);
    };

    Process.prototype.enqueue = function(sender, value) {
      var ref;
      if (this.flags & TERMINATED) {
        return sender.value = false;
      } else {
        return (ref = this._in()).enqueue.apply(ref, arguments);
      }
    };

    Process.prototype.dequeue = function(receiver) {
      var ref;
      if (this.flags & TERMINATED) {
        return receiver.value = this.value;
      } else {
        return (ref = this._out()).dequeue.apply(ref, arguments);
      }
    };

    Process.prototype.isScheduled = function() {
      return !!(this.flags & SCHEDULED);
    };

    Process.prototype.isRunning = function() {
      return !!(this.flags & RUNNING);
    };

    Process.prototype.isBlocked = function() {
      return !!(this.flags & BLOCKED);
    };

    Process.prototype.isTerminated = function() {
      return !!(this.flags & TERMINATED);
    };

    Process.prototype.block = function(awaitee, value1) {
      this.awaitee = awaitee;
      this.value = value1;
      if (!(this.flags & RUNNING)) {
        this["throw"]();
      }
      this.flags = BLOCKED;
      return this;
    };

    Process.prototype.proceed = function(value, isFinal) {
      var prior;
      if (isFinal == null) {
        isFinal = false;
      }
      if (!(this.flags & (INCIPIENT | BLOCKED))) {
        this["throw"]();
      }
      this.awaitee = null;
      prior = this.value;
      this.value = value;
      this.isFinal = isFinal;
      schedule(this);
      return prior;
    };

    Process.prototype.exit = function(value) {
      var child, pid, ref;
      if (this.children != null) {
        ref = this.children;
        for (pid in ref) {
          child = ref[pid];
          child.parent = null;
        }
        this.children = null;
      }
      return this.kill(null, value);
    };

    Process.prototype.kill = function(error, value) {
      var child, pid, ref, ref1, ref2, ref3;
      if (error == null) {
        error = null;
      }
      this.flags = TERMINATED;
      if (error != null) {
        this.flags |= ERROR;
        this.value = error;
      } else {
        this.value = value;
      }
      if ((ref = this.cin) != null) {
        ref.close();
      }
      if ((ref1 = this.cout) != null) {
        ref1.close(value);
      }
      if (this.children != null) {
        ref2 = this.children;
        for (pid in ref2) {
          child = ref2[pid];
          child.kill(error, value);
        }
      }
      if ((ref3 = this.parent) != null) {
        delete ref3.children[this.id];
      }
      delete table[this.id];
      if (error != null) {
        console.log(error);
        throw error;
      }
      return value;
    };

    Process.prototype.toString = function() {
      var id, ref, ref1, ref2, ref3, ref4, ref5;
      return "[object Process] {\n  id:       " + this.id + "\n  state:    " + (this.flagsToString()) + "\n  parent:   " + ((ref = (ref1 = this.parent) != null ? ref1.id : void 0) != null ? ref : null) + "\n  children: [" + ((function() {
        var results;
        results = [];
        for (id in this.children) {
          results.push(id);
        }
        return results;
      }).call(this)) + "]\n  I/O:      " + ((ref2 = (ref3 = this.cin) != null ? ref3.id : void 0) != null ? ref2 : null) + "/" + ((ref4 = (ref5 = this.cout) != null ? ref5.id : void 0) != null ? ref4 : null) + "\n}";
    };

    Process.prototype.toTree = function(indent) {
      var id, p, ref, ref1, ref2, ref3, ref4, s;
      if (indent == null) {
        indent = 0;
      }
      s = "" + ('  '.repeat(indent)) + this.id + " " + (this.flagsToString());
      if (this.awaitee != null) {
        s += " " + (this.awaitee.direction()) + this.awaitee.id;
      }
      if ((this.cin != null) || (this.cout != null)) {
        s += " (" + ((ref = (ref1 = this.cin) != null ? ref1.id : void 0) != null ? ref : null) + "/" + ((ref2 = (ref3 = this.cout) != null ? ref3.id : void 0) != null ? ref2 : null) + ")";
      }
      s += "\n";
      ref4 = this.children;
      for (id in ref4) {
        p = ref4[id];
        s += p.toTree(indent + 1);
      }
      return s;
    };

    Process.prototype.flagsToString = function() {
      var flags, k, n, str, v;
      flags = {
        INCIPIENT: INCIPIENT,
        SCHEDULED: SCHEDULED,
        RUNNING: RUNNING,
        BLOCKED: BLOCKED,
        TERMINATED: TERMINATED,
        ERROR: ERROR
      };
      n = 0;
      str = ((function() {
        var results;
        n++;
        results = [];
        for (k in flags) {
          v = flags[k];
          if (this.flags & v) {
            results.push(k);
          }
        }
        return results;
      }).call(this)).join(' | ');
      if (n === 1) {
        return str;
      } else {
        return "(" + str + ")";
      }
    };

    return Process;

  })(Awaiter);

}).call(this);

},{"./awaiter":1,"./channel":4,"./queue":8}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Queue, pooled;

  pooled = require('./helpers').pooled;

  module.exports = Queue = (function() {
    var Cell;

    pooled(Cell = (function() {
      Cell.SIZE = 32;

      function Cell(prev) {
        this._prev = prev || null;
        this._next = null;
        if (this.array == null) {
          this.array = new Array(Cell.SIZE);
        }
        if (prev != null) {
          prev._next = this;
        }
      }

      return Cell;

    })());

    function Queue() {
      this.head = null;
      this.tail = null;
      this.length = 0;
      this.offset = 0;
    }

    Queue.prototype.enqueue = function(value) {
      var index;
      index = (this.offset + this.length) % Cell.SIZE;
      if (index === 0) {
        this.tail = Cell.alloc(this.tail);
      }
      if (this.length === 0) {
        this.head = this.tail;
      }
      this.tail.array[index] = value;
      return ++this.length;
    };

    Queue.prototype.dequeue = function() {
      var array, head, next, offset, value;
      if (this.length === 0) {
        return;
      }
      offset = this.offset, head = this.head;
      array = head.array;
      value = array[offset];
      array[offset] = void 0;
      if ((this.offset = (offset + 1) % Cell.SIZE) === 0) {
        if (next = head._next) {
          head.free();
          next._prev = null;
          this.head = next;
        }
      }
      if (--this.length === 0) {
        this.offset = 0;
        this.head.free();
        this.head = this.tail = null;
      }
      return value;
    };

    return Queue;

  })();

}).call(this);

},{"./helpers":5}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Operation, Process, Selector, isArray,
    slice = [].slice;

  Process = require('./process');

  Operation = require('./operation');

  isArray = require('./helpers').isArray;

  module.exports = Selector = (function() {
    var ACTIVATED, COMMITTED, COMPLETED, IMMEDIATE, INCIPIENT, Receive, Send, clear, commit, complete, delegable, destructure, first, iterate, last, randomly;

    Receive = Operation.Receive, Send = Operation.Send;

    INCIPIENT = 0x01;

    ACTIVATED = 0x02;

    COMMITTED = 0x04;

    COMPLETED = 0x08;

    IMMEDIATE = 0x10;

    Selector.prototype[(typeof Symbol !== "undefined" && Symbol !== null ? Symbol.iterator : void 0) || '@@iterator'] = function() {
      return this;
    };

    function Selector() {
      this.flags = INCIPIENT;
      this.process = Process.current();
      this.operations = [];
      this.alternative = null;
      this.arbiter = null;
      this.delegate = null;
      this.value = void 0;
    }

    first = function(a) {
      return a[0];
    };

    last = function(a) {
      return a[a.length - 1];
    };

    randomly = function(a) {
      return a[Math.random() * a.length | 0];
    };

    delegable = function(label) {
      if (typeof label === 'function') {
        return label;
      } else {
        return function(value, channel) {
          return {
            next: function() {
              return {
                value: {
                  label: label,
                  value: value,
                  channel: channel
                },
                done: true
              };
            }
          };
        };
      }
    };

    destructure = (function() {
      var out;
      out = [];
      return destructure = function() {
        var args, consequent;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (args.length) {
          switch (typeof (last = args.pop())) {
            case 'function':
              consequent = last;
              break;
            case 'string':
              consequent = delegable(last);
              break;
            default:
              args.push(last);
              consequent = delegable();
          }
        }
        out[0] = args;
        out[1] = consequent;
        return out;
      };
    })();

    commit = function(s, operation, value) {
      if (s.flags & COMMITTED) {
        throw new Error("Already committed");
      }
      s.flags |= COMMITTED;
      if (operation != null) {
        if (operation.selector !== s) {
          throw new Error("Foreign operation");
        }
        s.value = operation.value;
        s.delegate = operation.consequent(value, operation.channel);
      } else {
        s.delegate = s.alternative();
      }
      clear(s);
      s.alternative = null;
      s.arbiter = null;
    };

    clear = function(s) {
      var i, len, op, ref;
      ref = s.operations;
      for (i = 0, len = ref.length; i < len; i++) {
        op = ref[i];
        op.free();
      }
      s.operations.length = 0;
    };

    iterate = function(s, value) {
      var iteration;
      iteration = s.delegate.next(value);
      if (iteration.done) {
        complete(s);
      }
      return iteration;
    };

    complete = function(s) {
      s.flags = COMPLETED;
      s.process = null;
      s.delegate = null;
      return s.value = void 0;
    };

    Selector.select = function() {
      var consequent, i, len, op, operations, ref, s;
      ref = destructure.apply(null, arguments), operations = ref[0], consequent = ref[1];
      s = new Selector;
      for (i = 0, len = operations.length; i < len; i++) {
        op = operations[i];
        if (isArray(op)) {
          s.send(op, consequent);
        } else {
          s.receive(op, consequent);
        }
      }
      return s;
    };

    Selector.select.receive = function() {
      var ref;
      return (ref = new Selector).receive.apply(ref, arguments);
    };

    Selector.select.send = function() {
      var ref;
      return (ref = new Selector).send.apply(ref, arguments);
    };

    Selector.select.first = function() {
      return (new Selector).arbitrate(first);
    };

    Selector.select.last = function() {
      return (new Selector).arbitrate(last);
    };

    Selector.prototype.receive = function() {
      var channel, channels, consequent, i, len, ready, ref;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), channels = ref[0], consequent = ref[1];
      for (i = 0, len = channels.length; i < len; i++) {
        channel = channels[i];
        ready = channel.canProcessReceive();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Receive.alloc(this, consequent, channel));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            clear(this);
          }
          this.operations.push(Receive.alloc(this, consequent, channel));
        }
      }
      return this;
    };

    Selector.prototype.send = function() {
      var channel, consequent, i, len, pairs, ready, ref, ref1, value;
      if (~this.flags & INCIPIENT) {
        throw new Error;
      }
      ref = destructure.apply(null, arguments), pairs = ref[0], consequent = ref[1];
      for (i = 0, len = pairs.length; i < len; i++) {
        ref1 = pairs[i], channel = ref1[0], value = ref1[1];
        ready = channel.canProcessSend();
        if (this.flags & IMMEDIATE) {
          if (ready) {
            this.operations.push(Send.alloc(this, consequent, channel, value));
          }
        } else {
          if (ready) {
            this.flags |= IMMEDIATE;
            clear(this);
          }
          this.operations.push(Send.alloc(this, consequent, channel, value));
        }
      }
      return this;
    };

    Selector.prototype["else"] = function(alternative) {
      if (~this.flags & INCIPIENT) {
        throw new Error("Early");
      }
      this.flags &= ~INCIPIENT;
      if (this.flags & ACTIVATED || (this.alternative != null)) {
        throw new Error("Late");
      }
      this.alternative = delegable(alternative);
      return this;
    };

    Selector.prototype.arbitrate = function(arbiter) {
      if (this.flags & ACTIVATED || (this.arbiter != null)) {
        throw new Error("Late");
      }
      this.arbiter = arbiter;
      return this;
    };

    Selector.prototype.next = function(value) {
      var i, len, op, ref;
      if (~this.flags & ACTIVATED) {
        this.flags = this.flags & ~INCIPIENT | ACTIVATED;
        if (this.flags & IMMEDIATE) {
          op = (this.arbiter || randomly)(this.operations);
        }
        if (op != null) {
          if (op.type === 'send') {
            value = !op.channel.isClosed();
          }
          commit(this, op, value);
          return iterate(this, value);
        } else if (this.alternative) {
          commit(this);
          return iterate(this);
        } else {
          this.process.block(this);
          ref = this.operations;
          for (i = 0, len = ref.length; i < len; i++) {
            op = ref[i];
            op.detain();
          }
          return {
            value: void 0,
            done: false
          };
        }
      } else {
        return iterate(this, value);
      }
    };

    Selector.prototype.proceedWith = function(operation, value, isFinal) {
      commit(this, operation, value);
      this.flags |= ACTIVATED;
      this.process.value = this.value;
      return this.process.proceed(value, isFinal);
    };

    return Selector;

  })();

}).call(this);

},{"./helpers":5,"./operation":6,"./process":7}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Buffer, Callback, Channel, Process, Selector, alias, chan, fn, go, i, len, name, offer, poll, proc, receive, ref, select, send, sleep, slice, timeout,
    slice1 = [].slice;

  Process = require('./process');

  Channel = require('./channel');

  Buffer = require('./buffer');

  Selector = require('./selector');

  Callback = require('./callback');

  alias = require('./helpers').alias;

  slice = Array.prototype.slice;

  proc = function() {
    var p;
    return p = Process.spawn.apply(Process, arguments);
  };

  proc.async = (function() {
    var AsyncIterator, async;
    AsyncIterator = (function() {
      function AsyncIterator(generator1, args1, callback1) {
        this.generator = generator1;
        this.args = args1;
        this.callback = callback1;
        this.step = 0;
        this.result = {
          value: void 0,
          done: false
        };
      }

      AsyncIterator.prototype.next = function(input) {
        var error, output;
        switch (++this.step) {
          case 1:
            output = receive(proc(this.generator, this.args));
            break;
          case 2:
            try {
              output = this.callback(null, input);
            } catch (_error) {
              error = _error;
              this.callback(error);
            }
            this.result.done = true;
        }
        this.result.value = output;
        return this.result;
      };

      return AsyncIterator;

    })();
    return async = function(generator) {
      return function(_) {
        var g;
        g = function() {
          var args, callback, i;
          args = 2 <= arguments.length ? slice1.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), callback = arguments[i++];
          return new AsyncIterator(generator, args, callback);
        };
        proc(g, arguments);
      };
    };
  })();

  (function() {
    var f, i, len, name, ref;
    f = function(name) {
      return function() {
        var ref;
        return (ref = Process.current())[name].apply(ref, arguments);
      };
    };
    ref = "enqueue dequeue isClosed isDone canProcessReceive canProcessSend".split(/\s+/);
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      proc[name] = f(name);
    }
  })();

  proc.dump = Process.dump;

  go = function() {
    var p;
    p = Process.spawn.apply(Process, arguments);
    return p.out();
  };

  chan = function(buffer, transducer) {
    var ch;
    return ch = new Channel(buffer, transducer);
  };

  ref = ['fixed', 'sliding', 'dropping'];
  for (i = 0, len = ref.length; i < len; i++) {
    name = ref[i];
    fn = Buffer[name];
    chan[name] = (function(fn) {
      return function() {
        var rest, size;
        size = arguments[0], rest = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
        return chan.apply(null, [fn(size)].concat(slice1.call(rest)));
      };
    })(fn);
  }

  chan.single = function(transducer) {
    var callback, ch;
    ch = chan(null, transducer);
    receive.async(ch, callback = function(channel, value) {
      if (ch.buffer != null) {
        ch.buffer.close;
        ch.buffer = null;
      }
      ch.flags |= 8;
      return ch.close(value);
    });
    return ch;
  };

  receive = function() {
    var channel, p;
    p = Process.current();
    switch (arguments.length) {
      case 0:
        channel = p._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.dequeue(p);
  };

  receive.async = function(channel, fn) {
    var callback, immediate, result;
    callback = Callback.alloc(channel, fn);
    immediate = channel.canProcessReceive();
    result = channel.dequeue(callback);
    if (immediate) {
      callback.proceed(result, channel.isDone());
    }
    return result;
  };

  send = function() {
    var channel, p, value;
    p = Process.current();
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = p._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    return channel.enqueue(p, value);
  };

  send.async = function(channel, value, fn) {
    var callback, immediate, result;
    callback = Callback.alloc(channel, fn);
    immediate = channel.canProcessSend();
    result = channel.enqueue(callback, value);
    if (immediate) {
      callback.proceed(result, channel.isClosed());
    }
    return result;
  };

  select = Selector.select;

  poll = function() {
    var channel;
    switch (arguments.length) {
      case 0:
        channel = Process.current()._in();
        break;
      case 1:
        channel = arguments[0];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessReceive()) {
      return receive.async(channel);
    }
  };

  offer = function() {
    var channel, value;
    switch (arguments.length) {
      case 1:
        value = arguments[0];
        channel = Process.current()._out();
        break;
      case 2:
        channel = arguments[0], value = arguments[1];
        break;
      default:
        throw new Error("Arity");
    }
    if (channel.canProcessSend()) {
      return send.async(channel, value);
    } else {
      return false;
    }
  };

  timeout = function() {
    var args, ch, fn, ms;
    ms = arguments[0], fn = arguments[1], args = 3 <= arguments.length ? slice1.call(arguments, 2) : [];
    ch = chan();
    if (typeof ms === 'function') {
      fn = arguments[0], ms = arguments[1];
    }
    setTimeout(((function(_this) {
      return function() {
        return ch.close(fn != null ? fn.apply(_this, args) : void 0);
      };
    })(this)), ms);
    return ch.out();
  };

  sleep = function() {
    return receive(timeout.apply(null, arguments));
  };

  alias({
    single: 'promise'
  }, chan);

  alias({
    receive: 'get take',
    send: 'put',
    select: 'alts'
  }, select, module.exports = {
    proc: proc,
    chan: chan,
    go: go,
    receive: receive,
    send: send,
    select: select,
    poll: poll,
    offer: offer,
    timeout: timeout,
    sleep: sleep
  });

}).call(this);

},{"./buffer":2,"./callback":3,"./channel":4,"./helpers":5,"./process":7,"./selector":9}]},{},[10])(10)
});